/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

options
{
    STATIC = false;
    UNICODE_INPUT = true;
    // DEBUG_TOKEN_MANAGER = true;
    // DEBUG_PARSER = true;
}

PARSER_BEGIN(FMParser)

package org.apache.freemarker.core;

import org.apache.freemarker.core.*;
import org.apache.freemarker.core.outputformat.*;
import org.apache.freemarker.core.outputformat.impl.*;
import org.apache.freemarker.core.model.*;
import org.apache.freemarker.core.model.impl.*;
import org.apache.freemarker.core.util.*;
import java.io.*;
import java.util.*;
import java.nio.charset.Charset;
import java.nio.charset.UnsupportedCharsetException;

/**
 * This class is generated by JavaCC from a grammar file.
 */
public class FMParser {

    private static final int ITERATOR_BLOCK_KIND_LIST = 0; 
    private static final int ITERATOR_BLOCK_KIND_ITEMS = 1;
    private static final int ITERATOR_BLOCK_KIND_USER_DIRECTIVE = 2;

    private static class ParserIteratorBlockContext {
        /**
         * loopVarName in <#list ... as loopVarName> or <#items as loopVarName>; null after we left the nested
         * block of #list or #items, respectively.
         */
        private String loopVarName;
        
        /**
         * loopVar1Name in <#list ... as k, loopVar2Name> or <#items as k, loopVar2Name>; null after we left the nested
         * block of #list or #items, respectively.
         */
        private String loopVar2Name;
        
        /**
         * See the ITERATOR_BLOCK_KIND_... costants.
         */
        private int kind;
        
        /**
         * Is this a key-value pair listing? When there's a nested #items, it's only set there. 
         */
        private boolean hashListing;
    }

    private Template template;

    private boolean stripWhitespace, stripText;
    private int incompatibleImprovements;
    private OutputFormat outputFormat;
    private AutoEscapingPolicy autoEscapingPolicy;
    private boolean autoEscaping;
    private ParsingConfiguration pCfg;
    private InputStream streamToUnmarkWhenEncEstabd;

    /** Keeps track of #list nesting. */
    private List/*<ParserIteratorBlockContext>*/ iteratorBlockContexts;
    
    /**
     * Keeps track of the nesting depth of directives that support #break.
     */
    private int breakableDirectiveNesting;

    private boolean inMacro, inFunction;
    private LinkedList escapes = new LinkedList();
    private int mixedContentNesting; // for stripText

    FMParser(Template template, Reader reader,
            ParsingConfiguration pCfg, OutputFormat outputFormat, AutoEscapingPolicy autoEscapingPolicy,
            InputStream streamToUnmarkWhenEncEstabd) {
        this(template, true, readerToTokenManager(reader, pCfg),
                pCfg, outputFormat, autoEscapingPolicy,
                streamToUnmarkWhenEncEstabd);
    }

    private static FMParserTokenManager readerToTokenManager(Reader reader, ParsingConfiguration pCfg) {
        SimpleCharStream simpleCharStream = new SimpleCharStream(reader, 1, 1);
        simpleCharStream.setTabSize(pCfg.getTabSize());
        return new FMParserTokenManager(simpleCharStream);
    }

    FMParser(Template template, boolean newTemplate, FMParserTokenManager tkMan,
            ParsingConfiguration pCfg, OutputFormat contextOutputFormat, AutoEscapingPolicy contextAutoEscapingPolicy,
    		InputStream streamToUnmarkWhenEncEstabd) {
        this(tkMan);

        _NullArgumentException.check(pCfg);
        this.pCfg = pCfg;
        
        this.streamToUnmarkWhenEncEstabd = streamToUnmarkWhenEncEstabd;

        _NullArgumentException.check(template);
        this.template = template;

        int incompatibleImprovements = pCfg.getIncompatibleImprovements().intValue();
        token_source.incompatibleImprovements = incompatibleImprovements;
        this.incompatibleImprovements = incompatibleImprovements;

        {
            OutputFormat outputFormatFromExt = pCfg.getRecognizeStandardFileExtensions() ? getFormatFromStdFileExt()
                    : null;
            outputFormat = contextOutputFormat != null ? contextOutputFormat
                    : outputFormatFromExt != null ? outputFormatFromExt
                    : pCfg.getOutputFormat();
            autoEscapingPolicy = contextAutoEscapingPolicy != null ? contextAutoEscapingPolicy
                    : outputFormatFromExt != null ? AutoEscapingPolicy.ENABLE_IF_DEFAULT
                    : pCfg.getAutoEscapingPolicy();
        }
        recalculateAutoEscapingField();

        token_source.setParser(this);

        TagSyntax tagSyntax = pCfg.getTagSyntax();
        switch (tagSyntax) {
        case AUTO_DETECT:
            token_source.autodetectTagSyntax = true;
            break;
        case ANGLE_BRACKET:
            token_source.squBracTagSyntax = false;
            break;
        case SQUARE_BRACKET:
            token_source.squBracTagSyntax = true;
            break;
        default:
            throw new BugException("Unsupported tagSyntax: " + tagSyntax);
        }

        this.stripWhitespace = pCfg.getWhitespaceStripping();

        // If this is a Template under construction, we do the below.
        // If this is just the enclosing Template for ?eval or such, we must not modify it.
        if (newTemplate) {
            template.setAutoEscapingPolicy(autoEscapingPolicy);
            template.setOutputFormat(outputFormat);
        }
    }
    
    void setupStringLiteralMode(FMParserTokenManager parentTokenSource, OutputFormat outputFormat) {
        token_source.SwitchTo(NODIRECTIVE);
        
        this.outputFormat = outputFormat;
        recalculateAutoEscapingField();                                
    }

    void tearDownStringLiteralMode(FMParserTokenManager parentTokenSource) {
        // Nothing to do ATM
    }

    private OutputFormat getFormatFromStdFileExt() {
        String name = template.getSourceOrLookupName();
        if (name == null) {
            return null;
        }

        int ln = name.length();
        if (ln < 5) return null;

        char c = name.charAt(ln - 5);
        if (c != '.') return null;

        c = name.charAt(ln - 4);
        if (c != 'f' && c != 'F') return null;

        c = name.charAt(ln - 3);
        if (c != 't' && c != 'T') return null;

        c = name.charAt(ln - 2);
        if (c != 'l' && c != 'L') return null;

        c = name.charAt(ln - 1);
        try {
            // Note: We get the output formats by name, so that custom overrides take effect.
            if (c == 'h' || c == 'H') {
                return template.getConfiguration().getOutputFormat(HTMLOutputFormat.INSTANCE.getName());
                }
            if (c == 'x' || c == 'X') {
                return template.getConfiguration().getOutputFormat(XMLOutputFormat.INSTANCE.getName());
            }
        } catch (UnregisteredOutputFormatException e) {
            throw new BugException("Unregistered std format", e);
        }
        return null;
    }
    
    /**
     * Updates the {@link #autoEscaping} field based on the {@link #autoEscapingPolicy} and {@link #outputFormat} fields.
     */
    private void recalculateAutoEscapingField() {
        if (outputFormat instanceof MarkupOutputFormat) {
            if (autoEscapingPolicy == AutoEscapingPolicy.ENABLE_IF_DEFAULT) {
                autoEscaping = ((MarkupOutputFormat) outputFormat).isAutoEscapedByDefault();
            } else if (autoEscapingPolicy == AutoEscapingPolicy.ENABLE_IF_SUPPORTED) {
                autoEscaping = true;
            } else if (autoEscapingPolicy == AutoEscapingPolicy.DISABLE) {
                autoEscaping = false;
            } else {
                throw new BugException("Unhandled autoEscaping enum: " + autoEscapingPolicy);
            }
        } else {
            autoEscaping = false;
        }
    }
    
    MarkupOutputFormat getMarkupOutputFormat() {
        return outputFormat instanceof MarkupOutputFormat ? (MarkupOutputFormat) outputFormat : null;
    }

    /**
     * Don't use it, unless you are developing FreeMarker itself.
     */
    public TagSyntax _getLastTagSyntax() {
        return token_source.squBracTagSyntax ? TagSyntax.SQUARE_BRACKET : TagSyntax.ANGLE_BRACKET;
    }

    /**
     * Throw an exception if the expression passed in is a String Literal
     */
    private void notStringLiteral(ASTExpression exp, String expected) throws ParseException {
        if (exp instanceof ASTExpStringLiteral) {
            throw new ParseException(
                    "Found string literal: " + exp + ". Expecting: " + expected,
                    exp);
        }
    }

    /**
     * Throw an exception if the expression passed in is a Number Literal
     */
    private void notNumberLiteral(ASTExpression exp, String expected) throws ParseException {
        if (exp instanceof ASTExpNumberLiteral) {
            throw new ParseException(
                    "Found number literal: " + exp.getCanonicalForm() + ". Expecting " + expected,
                    exp);
        }
    }

    /**
     * Throw an exception if the expression passed in is a boolean Literal
     */
    private void notBooleanLiteral(ASTExpression exp, String expected) throws ParseException {
        if (exp instanceof ASTExpBooleanLiteral) {
            throw new ParseException("Found: " + exp.getCanonicalForm() + ". Expecting " + expected, exp);
        }
    }

    /**
     * Throw an exception if the expression passed in is a Hash Literal
     */
    private void notHashLiteral(ASTExpression exp, String expected) throws ParseException {
        if (exp instanceof ASTExpHashLiteral) {
            throw new ParseException(
                    "Found hash literal: " + exp.getCanonicalForm() + ". Expecting " + expected,
                    exp);
        }
    }

    /**
     * Throw an exception if the expression passed in is a List Literal
     */
    private void notListLiteral(ASTExpression exp, String expected)
            throws ParseException
    {
        if (exp instanceof ASTExpListLiteral) {
            throw new ParseException(
                    "Found list literal: " + exp.getCanonicalForm() + ". Expecting " + expected,
                    exp);
        }
    }

    /**
     * Throw an exception if the expression passed in is a literal other than of the numerical type
     */
    private void numberLiteralOnly(ASTExpression exp) throws ParseException {
        notStringLiteral(exp, "number");
        notListLiteral(exp, "number");
        notHashLiteral(exp, "number");
        notBooleanLiteral(exp, "number");
    }

    /**
     * Throw an exception if the expression passed in is not a string.
     */
    private void stringLiteralOnly(ASTExpression exp) throws ParseException {
        notNumberLiteral(exp, "string");
        notListLiteral(exp, "string");
        notHashLiteral(exp, "string");
        notBooleanLiteral(exp, "string");
    }

    /**
     * Throw an exception if the expression passed in is a literal other than of the boolean type
     */
    private void booleanLiteralOnly(ASTExpression exp) throws ParseException {
        notStringLiteral(exp, "boolean (true/false)");
        notListLiteral(exp, "boolean (true/false)");
        notHashLiteral(exp, "boolean (true/false)");
        notNumberLiteral(exp, "boolean (true/false)");
    }

    private ASTExpression escapedExpression(ASTExpression exp) {
        if (!escapes.isEmpty()) {
            return ((ASTDirEscape) escapes.getFirst()).doEscape(exp);
        } else {
            return exp;
        }
    }

    private boolean getBoolean(ASTExpression exp, boolean legacyCompat) throws ParseException {
        TemplateModel tm = null;
        try {
            tm = exp.eval(null);
        } catch (Exception e) {
            throw new ParseException(e.getMessage()
                    + "\nCould not evaluate expression: "
                    + exp.getCanonicalForm(),
                    exp,
                    e);
        }
        if (tm instanceof TemplateBooleanModel) {
            try {
                return ((TemplateBooleanModel) tm).getAsBoolean();
            } catch (TemplateModelException tme) {
            }
        }
        if (legacyCompat && tm instanceof TemplateScalarModel) {
            try {
                return _StringUtil.getYesNo(((TemplateScalarModel) tm).getAsString());
            } catch (Exception e) {
                throw new ParseException(e.getMessage()
                        + "\nExpecting boolean (true/false), found: " + exp.getCanonicalForm(),
                        exp);
            }
        }
        throw new ParseException("Expecting boolean (true/false) parameter", exp);
    }
    
    void checkCurrentOutputFormatCanEscape(Token start) throws ParseException {
        if (!(outputFormat instanceof MarkupOutputFormat)) {
            throw new ParseException("The current output format can't do escaping: " + outputFormat,
                    template, start);
        }
    }    
    
    private ParserIteratorBlockContext pushIteratorBlockContext() {
        if (iteratorBlockContexts == null) {
            iteratorBlockContexts = new ArrayList(4);
        }
        ParserIteratorBlockContext newCtx = new ParserIteratorBlockContext();
        iteratorBlockContexts.add(newCtx);
        return newCtx;
    }
    
    private void popIteratorBlockContext() {
        iteratorBlockContexts.remove(iteratorBlockContexts.size() - 1);
    }
    
    private ParserIteratorBlockContext peekIteratorBlockContext() {
        int size = iteratorBlockContexts != null ? iteratorBlockContexts.size() : 0;
        return size != 0 ? (ParserIteratorBlockContext) iteratorBlockContexts.get(size - 1) : null; 
    }
    
    private void checkLoopVariableBuiltInLHO(String loopVarName, ASTExpression lhoExp, Token biName)
            throws ParseException {
        int size = iteratorBlockContexts != null ? iteratorBlockContexts.size() : 0;
        for (int i = size - 1; i >= 0; i--) {
            ParserIteratorBlockContext ctx = (ParserIteratorBlockContext) iteratorBlockContexts.get(i);
            if (loopVarName.equals(ctx.loopVarName) || loopVarName.equals(ctx.loopVar2Name)) {
                if (ctx.kind == ITERATOR_BLOCK_KIND_USER_DIRECTIVE) {
			        throw new ParseException(
			                "The left hand operand of ?" + biName.image
			                + " can't be the loop variable of an user defined directive: "
			                +  loopVarName,
			                lhoExp);
                }
                return;  // success
            }
        }
        throw new ParseException(
                "The left hand operand of ?" + biName.image + " must be a loop variable, "
                + "but there's no loop variable in scope with this name: " + loopVarName,
                lhoExp);
    }

}

PARSER_END(FMParser)

/**
 * The lexer portion defines 5 lexical states:
 * DEFAULT, FM_EXPRESSION, IN_PAREN, NO_PARSE, and EXPRESSION_COMMENT.
 * The DEFAULT state is when you are parsing
 * text but are not inside a FreeMarker expression.
 * FM_EXPRESSION is the state you are in
 * when the parser wants a FreeMarker expression.
 * IN_PAREN is almost identical really. The difference
 * is that you are in this state when you are within
 * FreeMarker expression and also within (...).
 * This is a necessary subtlety because the
 * ">" and ">=" symbols can only be used
 * within parentheses because otherwise, it would
 * be ambiguous with the end of a directive.
 * So, for example, you enter the FM_EXPRESSION state
 * right after a ${ and leave it after the matching }.
 * Or, you enter the FM_EXPRESSION state right after
 * an "<if" and then, when you hit the matching ">"
 * that ends the if directive,
 * you go back to DEFAULT lexical state.
 * If, within the FM_EXPRESSION state, you enter a
 * parenthetical expression, you enter the IN_PAREN
 * state.
 * Note that whitespace is ignored in the
 * FM_EXPRESSION and IN_PAREN states
 * but is passed through to the parser as PCDATA in the DEFAULT state.
 * NO_PARSE and EXPRESSION_COMMENT are extremely simple
 * lexical states. NO_PARSE is when you are in a comment
 * block and EXPRESSION_COMMENT is when you are in a comment
 * that is within an FTL expression.
 */
TOKEN_MGR_DECLS:
{

    private static final String PLANNED_DIRECTIVE_HINT
            = "(If you have seen this directive in use elsewhere, this was a planned directive, "
                + "so maybe you need to upgrade FreeMarker.)";

    /**
     * The noParseTag is set when we enter a block of text that the parser more or less ignores. These are <#noParse>
      a    nd
     * <#-- ... --->. This variable tells us what the closing tag should be, and when we hit that, we resume parsing.
     * Note that with this scheme, <#noParse> tags and comments cannot nest recursively.
     */
    String noParseTag;

    /**
     * Keeps track of how deeply nested we have the hash literals. This is necessary since we need to be able to
     * distinguish the } used to close a hash literal and the one used to close a ${
     */
    private FMParser parser;
    private int postInterpolationLexState = -1;
    private int hashLiteralNesting;
    private int parenthesisNesting;
    private int bracketNesting;
    private boolean inFTLHeader;
    boolean squBracTagSyntax,
            autodetectTagSyntax,
            directiveSyntaxEstablished,
            inInvocation;
    int incompatibleImprovements;

    void setParser(FMParser parser) {
        this.parser = parser;
    }

    /**
     * This method handles tag syntax ('<' VS '['), and also participates in naming convention detection.
     * If you update this logic, take a look at the UNKNOWN_DIRECTIVE token too. 
     */
    private void handleTagSyntaxAndSwitch(Token tok, int newLexState) {
        final String image = tok.image;
        
        char firstChar = image.charAt(0);
        if (autodetectTagSyntax && !directiveSyntaxEstablished) {
            squBracTagSyntax = (firstChar == '[');
        }
        if ((firstChar == '[' && !squBracTagSyntax) || (firstChar == '<' && squBracTagSyntax)) {
            tok.kind = STATIC_TEXT_NON_WS;
            return;
        }
        
        directiveSyntaxEstablished = true;
        
        SwitchTo(newLexState);
    }

    static char getTagNameCharAt(Token tok, int charIdxInName) {
        final String image = tok.image;
        
        // Skip tag delimiter:
        int idx = 0;
        for (;;) {
            final char c = image.charAt(idx);
            if (c != '<' && c != '[' && c != '/' && c != '#') {
                break;
            }
            idx++;
        }

        return image.charAt(idx + charIdxInName);
    }

    private void unifiedCall(Token tok) {
        char firstChar = tok.image.charAt(0);
        if (autodetectTagSyntax && !directiveSyntaxEstablished) {
            squBracTagSyntax = (firstChar == '[');
        }
        if (squBracTagSyntax && firstChar == '<') {
            tok.kind = STATIC_TEXT_NON_WS;
            return;
        }
        if (!squBracTagSyntax && firstChar == '[') {
            tok.kind = STATIC_TEXT_NON_WS;
            return;
        }
        directiveSyntaxEstablished = true;
        SwitchTo(NO_SPACE_EXPRESSION);
    }

    private void unifiedCallEnd(Token tok) {
        char firstChar = tok.image.charAt(0);
        if (squBracTagSyntax && firstChar == '<') {
            tok.kind = STATIC_TEXT_NON_WS;
            return;
        }
        if (!squBracTagSyntax && firstChar == '[') {
            tok.kind = STATIC_TEXT_NON_WS;
            return;
        }
    }

    private void closeBracket(Token tok) {
        if (bracketNesting > 0) {
            --bracketNesting;
        } else {
            tok.kind = DIRECTIVE_END;
            if (inFTLHeader) {
                eatNewline();
                inFTLHeader = false;
            }
            SwitchTo(DEFAULT);
        }
    }
    
    private void startInterpolation(Token tok) {
        if (postInterpolationLexState != -1) {
            char c = tok.image.charAt(0);
            throw new TokenMgrError(
                    "You can't start an interpolation (" + c + "{...}) here "
                    + "as you are inside another interpolation.)",
                    TokenMgrError.LEXICAL_ERROR,
                    tok.beginLine, tok.beginColumn,
                    tok.endLine, tok.endColumn);
        }
        postInterpolationLexState = curLexState;
        SwitchTo(FM_EXPRESSION);
    }

    /**
     * @param tok
     *         Assumed to be an '}', or something that is the closing pair of another "mirror image" character.
     */
    private void endInterpolation(Token tok) {
        if (postInterpolationLexState == -1) {
            char c = tok.image.charAt(0);
            throw new TokenMgrError(
                    "You can't have an \"" + c + "\" here, as there's nothing open that it could close.",
                    TokenMgrError.LEXICAL_ERROR,
                    tok.beginLine, tok.beginColumn,
                    tok.endLine, tok.endColumn);
        }
        SwitchTo(postInterpolationLexState);
        postInterpolationLexState = -1;
    }

    private void eatNewline() {
        int charsRead = 0;
        try {
            while (true) {
                char c = input_stream.readChar();
                ++charsRead;
                if (!Character.isWhitespace(c)) {
                    input_stream.backup(charsRead);
                    return;
                } else if (c == '\r') {
                    char next = input_stream.readChar();
                    ++charsRead;
                    if (next != '\n') {
                        input_stream.backup(1);
                    }
                    return;
                } else if (c == '\n') {
                    return;
                }
            }
        } catch (IOException ioe) {
            input_stream.backup(charsRead);
        }
    }

    private void ftlHeader(Token matchedToken) {
        if (!directiveSyntaxEstablished) {
            squBracTagSyntax = matchedToken.image.charAt(0) == '[';
            directiveSyntaxEstablished = true;
            autodetectTagSyntax = false;
        }
        String img = matchedToken.image;
        char firstChar = img.charAt(0);
        char lastChar = img.charAt(img.length() - 1);
        if ((firstChar == '[' && !squBracTagSyntax) || (firstChar == '<' && squBracTagSyntax)) {
            matchedToken.kind = STATIC_TEXT_NON_WS;
        }
        if (matchedToken.kind != STATIC_TEXT_NON_WS) {
            if (lastChar != '>' && lastChar != ']') {
                SwitchTo(FM_EXPRESSION);
                inFTLHeader = true;
            } else {
                eatNewline();
            }
        }
    }
}

TOKEN:
{
    <#BLANK : " " | "\t" | "\n" | "\r">
    |
    <#START_TAG : "<#" | "[#">
    |
    <#END_TAG : "</#" | "[/#">
    |
    <#CLOSE_TAG1 : (<BLANK>)* (">" | "]")>
    |
    <#CLOSE_TAG2 : (<BLANK>)* ("/")? (">" | "]")>
    |
    /*
     * ATTENTION: Update _CoreAPI.*_BUILT_IN_DIRECTIVE_NAMES if you add new directives!
     */
    <ATTEMPT : <START_TAG> "attempt" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <RECOVER : <START_TAG> "recover" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); } 
    |
    <IF : <START_TAG> "if" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <ELSE_IF : <START_TAG> "elseIf" <BLANK>> {
        handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION);
    }
    |
    <LIST : <START_TAG> "list" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <ITEMS : <START_TAG> "items" (<BLANK>)+ <AS> <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <SEP : <START_TAG> "sep" <CLOSE_TAG1>>
    |
    <SWITCH : <START_TAG> "switch" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <CASE : <START_TAG> "case" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <ASSIGN : <START_TAG> "assign" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <GLOBALASSIGN : <START_TAG> "global" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <LOCALASSIGN : <START_TAG> "local" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <_INCLUDE : <START_TAG> "include" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <IMPORT : <START_TAG> "import" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <FUNCTION : <START_TAG> "function" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <MACRO : <START_TAG> "macro" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <VISIT : <START_TAG> "visit" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <STOP : <START_TAG> "stop" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <RETURN : <START_TAG> "return" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <SETTING : <START_TAG> "setting" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <OUTPUTFORMAT : <START_TAG> "outputFormat" <BLANK>> {
        handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION);
    }
    |
    <AUTOESC : <START_TAG> "autoEsc" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <NOAUTOESC : <START_TAG> "noAutoEsc" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <COMPRESS : <START_TAG> "compress" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <TERSE_COMMENT : ("<" | "[") "#--" > { noParseTag = "-->"; handleTagSyntaxAndSwitch(matchedToken, NO_PARSE); }
    |
    <NOPARSE: <START_TAG> "noParse" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, NO_PARSE);
        noParseTag = "noParse";
    }
    |
    <END_IF : <END_TAG> "if" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_LIST : <END_TAG> "list" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_ITEMS : <END_TAG> "items" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_SEP : <END_TAG> "sep" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_ATTEMPT : <END_TAG> "attempt" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_LOCAL : <END_TAG> "local" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_GLOBAL : <END_TAG> "global" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_ASSIGN : <END_TAG> "assign" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_FUNCTION : <END_TAG> "function" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_MACRO : <END_TAG> "macro" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_OUTPUTFORMAT : <END_TAG> "outputFormat" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <END_AUTOESC : <END_TAG> "autoEsc" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <END_NOAUTOESC : <END_TAG> "no" ("autoe"|"AutoE") "sc" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <END_COMPRESS : <END_TAG> "compress" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <END_SWITCH : <END_TAG> "switch" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <ELSE : <START_TAG> "else" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <BREAK : <START_TAG> "break" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <SIMPLE_RETURN : <START_TAG> "return" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <HALT : <START_TAG> "stop" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <FLUSH : <START_TAG> "flush" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <TRIM : <START_TAG> "t" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <LTRIM : <START_TAG> "lt" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <RTRIM : <START_TAG> "rt" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <NOTRIM : <START_TAG> "nt" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <DEFAUL : <START_TAG> "default" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <SIMPLE_NESTED : <START_TAG> "nested" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <NESTED : <START_TAG> "nested" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <SIMPLE_RECURSE : <START_TAG> "recurse" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <RECURSE : <START_TAG> "recurse" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <FALLBACK : <START_TAG> "fallback" <CLOSE_TAG2>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <ESCAPE : <START_TAG> "escape" <BLANK>> { handleTagSyntaxAndSwitch(matchedToken, FM_EXPRESSION); }
    |
    <END_ESCAPE : <END_TAG> "escape" <CLOSE_TAG1>> { handleTagSyntaxAndSwitch(matchedToken, DEFAULT); }
    |
    <NOESCAPE : <START_TAG> "noEscape" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <END_NOESCAPE : <END_TAG> "noEscape" <CLOSE_TAG1>> {
        handleTagSyntaxAndSwitch(matchedToken, DEFAULT);
    }
    |
    <UNIFIED_CALL : "<@" | "[@" > { unifiedCall(matchedToken); }
    |
    <UNIFIED_CALL_END : ("<" | "[") "/@" ((<ID>) ("."<ID>)*)? <CLOSE_TAG1>> { unifiedCallEnd(matchedToken); }
    |
    <FTL_HEADER : ("<#ftl" | "[#ftl") <BLANK>> { ftlHeader(matchedToken); }
    |
    <TRIVIAL_FTL_HEADER : ("<#ftl" | "[#ftl") ("/")? (">" | "]")> { ftlHeader(matchedToken); }
    |
    /*
     * ATTENTION: Update _CoreAPI.*_BUILT_IN_DIRECTIVE_NAMES if you add new directives!
     */
    <UNKNOWN_DIRECTIVE : ("[#" | "[/#" | "<#" | "</#") (["a"-"z", "A"-"Z", "_"])+>
    {
        char firstChar = matchedToken.image.charAt(0);

        if (!directiveSyntaxEstablished && autodetectTagSyntax) {
            squBracTagSyntax = (firstChar == '[');
            directiveSyntaxEstablished = true;
        }

        if (firstChar == '<' && squBracTagSyntax) {
            matchedToken.kind = STATIC_TEXT_NON_WS;
        } else if (firstChar == '[' && !squBracTagSyntax) {
            matchedToken.kind = STATIC_TEXT_NON_WS;
        } else {
            String dn = matchedToken.image;
            int index = dn.indexOf('#');
            dn = dn.substring(index + 1);

            // Until the tokenizer/parser is reworked, we have this quirk where something like <#list>
            // doesn't match any directive starter tokens, because that token requires whitespace after the
            // name as it should be followed by parameters. For now we work this around so we don't report
            // unknown directive:
            if (ASTDirective.BUILT_IN_DIRECTIVE_NAMES.contains(dn)) {
                throw new TokenMgrError(
                        "#" + dn + " is an existing directive, but the tag is malformed. " 
                        + " (See FreeMarker Manual / Directive Reference.)",
                        TokenMgrError.LEXICAL_ERROR,
                        matchedToken.beginLine, matchedToken.beginColumn + 1,
                        matchedToken.endLine, matchedToken.endColumn);
            }

            String tip = null;
            if (dn.equals("set") || dn.equals("var")) {
                tip = "Use #assign or #local or #global, depending on the intented scope "
                      + "(#assign is template-scope). " + PLANNED_DIRECTIVE_HINT;
            } else if (dn.equals("else_if") || dn.equals("elif") || dn.equals("elseif")) {
            	tip = "Use #elseIf instead.";
            } else if (dn.equals("no_escape")) {
            	tip = "Use #noEscape instead.";
            } else if (dn.equals("method")) {
            	tip = "Use #function instead.";
            } else if (dn.equals("head") || dn.equals("template") || dn.equals("fm")) {
            	tip = "You may meant #ftl.";
            } else if (dn.equals("try") || dn.equals("atempt")) {
            	tip = "You may meant #attempt.";
            } else if (dn.equals("for") || dn.equals("each") || dn.equals("iterate") || dn.equals("iterator")) {
                tip = "You may meant #list (http://freemarker.org/docs/ref_directive_list.html).";
            } else if (dn.equals("prefix")) {
                tip = "You may meant #import. " + PLANNED_DIRECTIVE_HINT;
            } else if (dn.equals("item") || dn.equals("row") || dn.equals("rows")) {
                tip = "You may meant #items.";
            } else if (dn.equals("separator") || dn.equals("separate") || dn.equals("separ")) {
                tip = "You may meant #sep.";
            } else if (dn.equals("outputformat")) {
            	tip = "Use #outputFormat instead.";
            } else if (dn.equals("noautoesc")) {
            	tip = "Use #noAutoEsc instead.";
            } else if (dn.equals("autoesc")) {
            	tip = "Use #autoEsc instead.";
            } else if (dn.equals("noparse")) {
            	tip = "Use #noParse instead.";
            } else {
                tip = "Help (latest version): http://freemarker.org/docs/ref_directive_alphaidx.html; "
                        + "you're using FreeMarker " + Configuration.getVersion() + ".";
            }
            throw new TokenMgrError(
                    "Unknown directive: #" + dn + (tip != null ? ". " + tip : ""),
                    TokenMgrError.LEXICAL_ERROR,
                    matchedToken.beginLine, matchedToken.beginColumn + 1,
                    matchedToken.endLine, matchedToken.endColumn);
        }
    }
}

<DEFAULT, NODIRECTIVE> TOKEN :
{
    <STATIC_TEXT_WS : ("\n" | "\r" | "\t" | " ")+>
    |
    // Find related: [interpolation prefixes]
    <STATIC_TEXT_NON_WS : (~["$", "<", "[", "{", "\n", "\r", "\t", " "])+>
    |
    // Find related: [interpolation prefixes]
    <STATIC_TEXT_FALSE_ALARM : "$" | "<" | "[" | "{"> // to handle a lone dollar sign or "<" or "# or <@ with whitespace after
    |
    // Find related: [interpolation prefixes]
    <DOLLAR_INTERPOLATION_OPENING : "${"> { startInterpolation(matchedToken); }
}

<FM_EXPRESSION, IN_PAREN, NAMED_PARAMETER_EXPRESSION> SKIP :
{
    < ( " " | "\t" | "\n" | "\r" )+ >
    |
    < ("<" | "[") ("#" | "!") "--"> : EXPRESSION_COMMENT
}

<EXPRESSION_COMMENT> SKIP:
{
    < (~["-", ">", "]"])+ >
    |
    < ">">
    |
    < "]">
    |
    < "-">
    |
    < "-->" | "--]">
    {
        if (parenthesisNesting > 0) SwitchTo(IN_PAREN);
        else if (inInvocation) SwitchTo(NAMED_PARAMETER_EXPRESSION);
        else SwitchTo(FM_EXPRESSION);
    }
}

<FM_EXPRESSION, IN_PAREN, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :
{
    <#ESCAPED_CHAR :
        "\\"
        (
            ("n" | "t" | "r" | "f" | "b" | "g" | "l" | "a" | "\\" | "'" | "\"" | "$" | "{")
            |
            ("x" ["0"-"9", "A"-"F", "a"-"f"])
        )
    >
    | 
    <STRING_LITERAL :
        (
            "\""
            ((~["\"", "\\"]) | <ESCAPED_CHAR>)*
            "\""
        )
        |
        (
            "'"
            ((~["'", "\\"]) | <ESCAPED_CHAR>)*
            "'"
        )
    >
    |
    <RAW_STRING : "r" (("\"" (~["\""])* "\"") | ("'" (~["'"])* "'"))>
    |
    <FALSE : "false">
    |
    <TRUE : "true">
    |
    <INTEGER : (["0"-"9"])+>
    |
    <DECIMAL : <INTEGER> "." <INTEGER>>
    |
    <DOT : ".">
    |
    <DOT_DOT : "..">
    |
    <DOT_DOT_LESS : "..<" | "..!" >
    |
    <DOT_DOT_ASTERISK : "..*" >
    |
    <BUILT_IN : "?">
    |
    <EXISTS : "??">
    |
    <ASSIGNMENT_EQUALS : "=">
    |
    <COMPARISON_EQUALS : "==">
    |
    <NOT_EQUALS : "!=">
    |
    <PLUS_EQUALS : "+=">
    |
    <MINUS_EQUALS : "-=">
    |
    <TIMES_EQUALS : "*=">
    |
    <DIV_EQUALS : "/=">
    |
    <MOD_EQUALS : "%=">
    |
    <PLUS_PLUS : "++">
    |
    <MINUS_MINUS : "--">
    |
    <LESS_THAN : "lt" | "\\lt" | "<" | "&lt;">
    |
    <LESS_THAN_EQUALS : "lte" | "\\lte" | "<=" | "&lt;=">
    |
    <ESCAPED_GT: "gt" | "\\gt" |  "&gt;">
    |
    <ESCAPED_GTE : "gte" | "\\gte" | "&gt;=">
    |
    <PLUS : "+">
    |
    <MINUS : "-">
    |
    <TIMES : "*">
    |
    <DOUBLE_STAR : "**">
    |
    <ELLIPSIS : "...">
    |
    <DIVIDE : "/">
    |
    <PERCENT : "%">
    |
    <AND : "&&" | "&amp;&amp;" | "\\and">
    |
    <OR : "||">
    |
    <EXCLAM : "!">
    |
    <COMMA : ",">
    |
    <SEMICOLON : ";">
    |
    <COLON : ":">
    |
    <OPEN_BRACKET : "[">
    {
        ++bracketNesting;
    }
    |
    <CLOSE_BRACKET : "]">
    {
        closeBracket(matchedToken);
    }
    |
    <OPEN_PAREN : "(">
    {
        ++parenthesisNesting;
        if (parenthesisNesting == 1) SwitchTo(IN_PAREN);
    }
    |
    <CLOSE_PAREN : ")">
    {
        --parenthesisNesting;
        if (parenthesisNesting == 0) {
            if (inInvocation) SwitchTo(NAMED_PARAMETER_EXPRESSION);
            else SwitchTo(FM_EXPRESSION);
        }
    }
    |
    <OPENING_CURLY_BRACKET : "{">
    {
        ++hashLiteralNesting;
    }
    |
    <CLOSING_CURLY_BRACKET : "}">
    {
        if (hashLiteralNesting == 0) endInterpolation(matchedToken);
        else --hashLiteralNesting;
    }
    |
    <IN : "in">
    |
    <AS : "as">
    |
    <USING : "using">
    |
    <ID: <ID_START_CHAR> (<ID_START_CHAR>|<ASCII_DIGIT>)*> {
        // Remove backslashes from Token.image:
        final String s = matchedToken.image;
        if (s.indexOf('\\') != -1) {
            final int srcLn = s.length(); 
            final char[] newS = new char[srcLn - 1];
            int dstIdx = 0;
            for (int srcIdx = 0; srcIdx < srcLn; srcIdx++) {
                final char c = s.charAt(srcIdx);
                if (c != '\\') {
                    newS[dstIdx++] = c;
                }
            }
            matchedToken.image = new String(newS, 0, dstIdx);
        }
    }
    |
    <OPEN_MISPLACED_INTERPOLATION : "${"> // Find related: [interpolation prefixes]
    {
        if ("".length() == 0) {  // prevents unreachabe "break" compilation error in generated Java
            char c = matchedToken.image.charAt(0);
            throw new TokenMgrError(
                    "You can't use \"" + c + "{\" here as you are already in FreeMarker-expression-mode. Thus, instead "
                    + "of " + c + "{myExpression}, just write myExpression. "
                    + "(" + c + "{...} is only needed where otherwise static text is expected, i.e, outside " 
                    + "FreeMarker tags and ${...}-s.)",
                    TokenMgrError.LEXICAL_ERROR,
                    matchedToken.beginLine, matchedToken.beginColumn,
                    matchedToken.endLine, matchedToken.endColumn);
        }
    }
    |
    <#NON_ESCAPED_ID_START_CHAR:
        [
            // This was generated on JDK 1.8.0_20 Win64 with src/main/misc/identifierChars/IdentifierCharGenerator.java
			"$", 
			"@" - "Z", 
			"_", 
			"a" - "z", 
			"\u00AA", 
			"\u00B5", 
			"\u00BA", 
			"\u00C0" - "\u00D6", 
			"\u00D8" - "\u00F6", 
			"\u00F8" - "\u1FFF", 
			"\u2071", 
			"\u207F", 
			"\u2090" - "\u209C", 
			"\u2102", 
			"\u2107", 
			"\u210A" - "\u2113", 
			"\u2115", 
			"\u2119" - "\u211D", 
			"\u2124", 
			"\u2126", 
			"\u2128", 
			"\u212A" - "\u212D", 
			"\u212F" - "\u2139", 
			"\u213C" - "\u213F", 
			"\u2145" - "\u2149", 
			"\u214E", 
			"\u2183" - "\u2184", 
			"\u2C00" - "\u2C2E", 
			"\u2C30" - "\u2C5E", 
			"\u2C60" - "\u2CE4", 
			"\u2CEB" - "\u2CEE", 
			"\u2CF2" - "\u2CF3", 
			"\u2D00" - "\u2D25", 
			"\u2D27", 
			"\u2D2D", 
			"\u2D30" - "\u2D67", 
			"\u2D6F", 
			"\u2D80" - "\u2D96", 
			"\u2DA0" - "\u2DA6", 
			"\u2DA8" - "\u2DAE", 
			"\u2DB0" - "\u2DB6", 
			"\u2DB8" - "\u2DBE", 
			"\u2DC0" - "\u2DC6", 
			"\u2DC8" - "\u2DCE", 
			"\u2DD0" - "\u2DD6", 
			"\u2DD8" - "\u2DDE", 
			"\u2E2F", 
			"\u3005" - "\u3006", 
			"\u3031" - "\u3035", 
			"\u303B" - "\u303C", 
			"\u3040" - "\u318F", 
			"\u31A0" - "\u31BA", 
			"\u31F0" - "\u31FF", 
			"\u3300" - "\u337F", 
			"\u3400" - "\u4DB5", 
			"\u4E00" - "\uA48C", 
			"\uA4D0" - "\uA4FD", 
			"\uA500" - "\uA60C", 
			"\uA610" - "\uA62B", 
			"\uA640" - "\uA66E", 
			"\uA67F" - "\uA697", 
			"\uA6A0" - "\uA6E5", 
			"\uA717" - "\uA71F", 
			"\uA722" - "\uA788", 
			"\uA78B" - "\uA78E", 
			"\uA790" - "\uA793", 
			"\uA7A0" - "\uA7AA", 
			"\uA7F8" - "\uA801", 
			"\uA803" - "\uA805", 
			"\uA807" - "\uA80A", 
			"\uA80C" - "\uA822", 
			"\uA840" - "\uA873", 
			"\uA882" - "\uA8B3", 
			"\uA8D0" - "\uA8D9", 
			"\uA8F2" - "\uA8F7", 
			"\uA8FB", 
			"\uA900" - "\uA925", 
			"\uA930" - "\uA946", 
			"\uA960" - "\uA97C", 
			"\uA984" - "\uA9B2", 
			"\uA9CF" - "\uA9D9", 
			"\uAA00" - "\uAA28", 
			"\uAA40" - "\uAA42", 
			"\uAA44" - "\uAA4B", 
			"\uAA50" - "\uAA59", 
			"\uAA60" - "\uAA76", 
			"\uAA7A", 
			"\uAA80" - "\uAAAF", 
			"\uAAB1", 
			"\uAAB5" - "\uAAB6", 
			"\uAAB9" - "\uAABD", 
			"\uAAC0", 
			"\uAAC2", 
			"\uAADB" - "\uAADD", 
			"\uAAE0" - "\uAAEA", 
			"\uAAF2" - "\uAAF4", 
			"\uAB01" - "\uAB06", 
			"\uAB09" - "\uAB0E", 
			"\uAB11" - "\uAB16", 
			"\uAB20" - "\uAB26", 
			"\uAB28" - "\uAB2E", 
			"\uABC0" - "\uABE2", 
			"\uABF0" - "\uABF9", 
			"\uAC00" - "\uD7A3", 
			"\uD7B0" - "\uD7C6", 
			"\uD7CB" - "\uD7FB", 
			"\uF900" - "\uFB06", 
			"\uFB13" - "\uFB17", 
			"\uFB1D", 
			"\uFB1F" - "\uFB28", 
			"\uFB2A" - "\uFB36", 
			"\uFB38" - "\uFB3C", 
			"\uFB3E", 
			"\uFB40" - "\uFB41", 
			"\uFB43" - "\uFB44", 
			"\uFB46" - "\uFBB1", 
			"\uFBD3" - "\uFD3D", 
			"\uFD50" - "\uFD8F", 
			"\uFD92" - "\uFDC7", 
			"\uFDF0" - "\uFDFB", 
			"\uFE70" - "\uFE74", 
			"\uFE76" - "\uFEFC", 
			"\uFF10" - "\uFF19", 
			"\uFF21" - "\uFF3A", 
			"\uFF41" - "\uFF5A", 
			"\uFF66" - "\uFFBE", 
			"\uFFC2" - "\uFFC7", 
			"\uFFCA" - "\uFFCF", 
			"\uFFD2" - "\uFFD7", 
			"\uFFDA" - "\uFFDC" 
        ]
    >
    |
    <#ESCAPED_ID_CHAR: "\\" ("-" | "." | ":")>
    |
    <#ID_START_CHAR: <NON_ESCAPED_ID_START_CHAR>|<ESCAPED_ID_CHAR>>
    |
    <#ASCII_DIGIT: ["0" - "9"]>
}

<FM_EXPRESSION, NO_SPACE_EXPRESSION, NAMED_PARAMETER_EXPRESSION> TOKEN :
{
    <DIRECTIVE_END : ">">
    {
        if (inFTLHeader) eatNewline();
        inFTLHeader = false;
        if (squBracTagSyntax) {
            matchedToken.kind = NATURAL_GT;
        } else {
            SwitchTo(DEFAULT);
        }
    }
    |
    <EMPTY_DIRECTIVE_END : "/>" | "/]">
    {
        if (inFTLHeader) eatNewline();
        inFTLHeader = false;
        SwitchTo(DEFAULT);
    }
}

<IN_PAREN> TOKEN :
{
    <NATURAL_GT : ">">
    |
    <NATURAL_GTE : ">=">
}

<NO_SPACE_EXPRESSION> TOKEN :
{
    <TERMINATING_WHITESPACE :  (["\n", "\r", "\t", " "])+> : FM_EXPRESSION
}

<NAMED_PARAMETER_EXPRESSION> TOKEN :
{
    <TERMINATING_EXCLAM : "!" (["\n", "\r", "\t", " "])+> : FM_EXPRESSION
}

<NO_PARSE> TOKEN :
{
    <TERSE_COMMENT_END : "-->" | "--]">
    {
        if (noParseTag.equals("-->")) {
            boolean squareBracket = matchedToken.image.endsWith("]");
            if ((squBracTagSyntax && squareBracket) || (!squBracTagSyntax && !squareBracket)) {
                matchedToken.image = matchedToken.image + ";"; 
                SwitchTo(DEFAULT);
            }
        }
    }
    |
    <MAYBE_END :
        ("<" | "[")
        "/#"
        (["a"-"z", "A"-"Z"])+
        ( " " | "\t" | "\n" | "\r" )*
        (">" | "]")
    >
    {
        StringTokenizer st = new StringTokenizer(image.toString(), " \t\n\r<>[]/#", false);
        if (st.nextToken().equals(noParseTag)) {
            matchedToken.image = matchedToken.image + ";"; 
            SwitchTo(DEFAULT);
        }
    }
    |
    <KEEP_GOING : (~["<", "[", "-"])+>
    |
    <LONE_LESS_THAN_OR_DASH : ["<", "[", "-"]>
}

// Now the actual parsing code, starting
// with the productions for FreeMarker's
// expression syntax.

/**
 * This is the same as ASTExpOr, since
 * OR is the operator with the lowest
 * precedence.
 */
ASTExpression ASTExpression() :
{
    ASTExpression exp;
}
{
    exp = ASTExpOr()
    {
        return exp;
    }
}

/**
 * Lowest level expression, a literal, a variable,
 * or a possibly more complex expression bounded
 * by parentheses.
 */
ASTExpression PrimaryExpression() :
{
    ASTExpression exp;
}
{
    (
        exp = ASTExpNumberLiteral()
        |   
        exp = ASTExpHashLiteral()
        |   
        exp = ASTExpStringLiteral(true)
        |   
        exp = ASTExpBooleanLiteral()
        |   
        exp = ASTExpListLiteral()
        |   
        exp = ASTExpVariable()
        |   
        exp = Parenthesis()
        |   
        exp = ASTExpBuiltInVariable()
    )
    (
        LOOKAHEAD(<DOT> | <OPEN_BRACKET> |<OPEN_PAREN> | <BUILT_IN> | <EXCLAM> | <TERMINATING_EXCLAM> | <EXISTS>)
        exp = AddSubExpression(exp)
    )*
    {
        return exp;
    }
}

ASTExpression Parenthesis() :
{
    ASTExpression exp, result;
    Token start, end;
}
{
    start = <OPEN_PAREN>
    exp = ASTExpression()
    end = <CLOSE_PAREN>
    {
        result = new ASTExpParenthesis(exp);
        result.setLocation(template, start, end);
        return result;
    }
}

/**
 * A primary expression preceded by zero or
 * more unary operators. (The only unary operator we
 * currently have is the NOT.)
 */
ASTExpression UnaryExpression() :
{
    ASTExpression exp, result;
    boolean haveNot = false;
    Token t = null, start = null;
}
{
    (
        result = ASTExpNegateOrPlus()
        |
        result = ASTExpNot()
        |
        result = PrimaryExpression()
    )
    {
        return result;
    }
}

ASTExpression ASTExpNot() : 
{
    Token t;
    ASTExpression exp, result = null;
    ArrayList nots = new ArrayList();
}
{
    (
        t = <EXCLAM> { nots.add(t); }
    )+
    exp = PrimaryExpression()
    {
        for (int i = 0; i < nots.size(); i++) {
            result = new ASTExpNot(exp);
            Token tok = (Token) nots.get(nots.size() -i -1);
            result.setLocation(template, tok, exp);
            exp = result;
        }
        return result;
    }
}

ASTExpression ASTExpNegateOrPlus() :
{
    ASTExpression exp, result;
    boolean isMinus = false;
    Token t;
}
{
    (
        t = <PLUS>
        |
        t = <MINUS> { isMinus = true; }
    )
    exp = PrimaryExpression()
    {
        result = new ASTExpNegateOrPlus(exp, isMinus);  
        result.setLocation(template, t, exp);
        return result;
    }
}

ASTExpression AdditiveExpression() :
{
    ASTExpression lhs, rhs, result;
    boolean plus;
}
{
    lhs = MultiplicativeExpression() { result = lhs; }
    (
        LOOKAHEAD(<PLUS>|<MINUS>)
        (
            (
                <PLUS> { plus = true; }
                |
                <MINUS> { plus = false; }
            )
        )
        rhs = MultiplicativeExpression()
        {
            if (plus) {
	            // plus is treated separately, since it is also
	            // used for concatenation.
                result = new ASTExpAddOrConcat(lhs, rhs);
            } else {
                numberLiteralOnly(lhs);
                numberLiteralOnly(rhs);
                result = new ASTExpArithmetic(lhs, rhs, ASTExpArithmetic.TYPE_SUBSTRACTION);
            }
            result.setLocation(template, lhs, rhs);
            lhs = result;
        }
    )*
    {
        return result;
    }
}

/**
 * A unary expression followed by zero or more
 * unary expressions with operators in between.
 */
ASTExpression MultiplicativeExpression() :
{
    ASTExpression lhs, rhs, result;
    int operation = ASTExpArithmetic.TYPE_MULTIPLICATION;
}
{
    lhs = UnaryExpression() { result = lhs; }
    (
        LOOKAHEAD(<TIMES>|<DIVIDE>|<PERCENT>)
        (
            (
                <TIMES> { operation = ASTExpArithmetic.TYPE_MULTIPLICATION; }
                |
                <DIVIDE> { operation = ASTExpArithmetic.TYPE_DIVISION; }
                |
                <PERCENT> {operation = ASTExpArithmetic.TYPE_MODULO; }
            )
        )
        rhs = UnaryExpression()
        {
            numberLiteralOnly(lhs);
            numberLiteralOnly(rhs);
            result = new ASTExpArithmetic(lhs, rhs, operation);
            result.setLocation(template, lhs, rhs);
            lhs = result;
        }
    )*
    {
        return result;
    }
}


ASTExpression EqualityExpression() :
{
    ASTExpression lhs, rhs, result;
    Token t;
}
{
    lhs = RelationalExpression() { result = lhs; }
    [
        LOOKAHEAD(<NOT_EQUALS>|<COMPARISON_EQUALS>)
        (
            t = <NOT_EQUALS> 
            |
            t = <COMPARISON_EQUALS>
        )
        rhs = RelationalExpression()
        {
	        notHashLiteral(lhs, "scalar");
	        notHashLiteral(rhs, "scalar");
	        notListLiteral(lhs, "scalar");
	        notListLiteral(rhs, "scalar");
	        result = new ASTExpComparison(lhs, rhs, t.image);
	        result.setLocation(template, lhs, rhs);
        }
    ]
    {
        return result;
    }
}

ASTExpression RelationalExpression() :
{
    ASTExpression lhs, rhs, result;
    Token t;
}
{
    lhs = RangeExpression() { result = lhs; }
    [
        LOOKAHEAD(<NATURAL_GTE>|<ESCAPED_GTE>|<NATURAL_GT>|<ESCAPED_GT>|<LESS_THAN_EQUALS>|<LESS_THAN_EQUALS>|<LESS_THAN>)
        (
            t = <NATURAL_GTE>
            |
            t = <ESCAPED_GTE>
            |
            t = <NATURAL_GT>
            |
            t = <ESCAPED_GT>
            |
            t = <LESS_THAN_EQUALS>
            |
            t = <LESS_THAN>
        )
        rhs = RangeExpression()
        {
            notHashLiteral(lhs, "scalar");
            notHashLiteral(rhs, "scalar");
            notListLiteral(lhs, "scalar");
            notListLiteral(rhs, "scalar");
            notStringLiteral(lhs, "number");
            notStringLiteral(rhs, "number");
            result = new ASTExpComparison(lhs, rhs, t.image);
            result.setLocation(template, lhs, rhs);
        }
    ]
    {
        return result;
    }
}

ASTExpression RangeExpression() :
{
    ASTExpression lhs, rhs = null, result;
    int endType;
    Token dotDot = null;
}
{
    lhs = AdditiveExpression() { result = lhs; }
    [
        LOOKAHEAD(1)  // To suppress warning
        (
            (
                (
                    <DOT_DOT_LESS> { endType = ASTExpRange.END_EXCLUSIVE; }
                    |
                    <DOT_DOT_ASTERISK> { endType = ASTExpRange.END_SIZE_LIMITED; }
                )
                rhs = AdditiveExpression()
            )
            | 
            (
                dotDot = <DOT_DOT> { endType = ASTExpRange.END_UNBOUND; }
                [
                    LOOKAHEAD(AdditiveExpression())
                    rhs = AdditiveExpression()
                    {
                        endType = ASTExpRange.END_INCLUSIVE;
                    }
                ]
            )
        )
        {
            numberLiteralOnly(lhs);
            if (rhs != null) {
                numberLiteralOnly(rhs);
            }
           
            ASTExpRange range = new ASTExpRange(lhs, rhs, endType);
            if (rhs != null) {
                range.setLocation(template, lhs, rhs);
            } else {
                range.setLocation(template, lhs, dotDot);
            }
            result = range;
        }
    ]
    {
        return result;
    }
}




ASTExpression ASTExpAnd() :
{
    ASTExpression lhs, rhs, result;
}
{
    lhs = EqualityExpression() { result = lhs; }
    (
        LOOKAHEAD(<AND>)
        <AND>
        rhs = EqualityExpression()
        {
            booleanLiteralOnly(lhs);
            booleanLiteralOnly(rhs);
            result = new ASTExpAnd(lhs, rhs);
            result.setLocation(template, lhs, rhs);
            lhs = result;
        }
    )*
    {
        return result;
    }
}

ASTExpression ASTExpOr() :
{
    ASTExpression lhs, rhs, result;
}
{
    lhs = ASTExpAnd() { result = lhs; }
    (
        LOOKAHEAD(<OR>)
        <OR>
        rhs = ASTExpAnd()
        {
            booleanLiteralOnly(lhs);
            booleanLiteralOnly(rhs);
            result = new ASTExpOr(lhs, rhs);
            result.setLocation(template, lhs, rhs);
            lhs = result;
        }
    )*
    {
        return result;
    }
}

ASTExpListLiteral ASTExpListLiteral() :
{
    ArrayList values = new ArrayList();
    Token begin, end;
}
{
    begin = <OPEN_BRACKET>
    values = PositionalArgs()
    end = <CLOSE_BRACKET>
    {
        ASTExpListLiteral result = new ASTExpListLiteral(values);
        result.setLocation(template, begin, end);
        return result;
    }
}

ASTExpression ASTExpNumberLiteral() :
{
    Token op = null, t;
}
{
    (
        t = <INTEGER>
        |
        t = <DECIMAL>
    )
    {
        String s = t.image;
        ASTExpression result = new ASTExpNumberLiteral(pCfg.getArithmeticEngine().toNumber(s));
        Token startToken = (op != null) ? op : t;
        result.setLocation(template, startToken, t);
        return result;
    }
}

ASTExpVariable ASTExpVariable() :
{
    Token t;
}
{
    t = <ID>
    {
        ASTExpVariable id = new ASTExpVariable(t.image);
        id.setLocation(template, t, t);
        return id;
    }
}

ASTExpression IdentifierOrStringLiteral() :
{
    ASTExpression exp;
}
{
    (
        exp = ASTExpVariable()
        |
        exp = ASTExpStringLiteral(false)
    )
    {
        return exp;
    }   
}

ASTExpBuiltInVariable ASTExpBuiltInVariable() :
{
    Token dot, name;
}
{
    dot = <DOT>
    name = <ID>
    {
        ASTExpBuiltInVariable result = null;

        TemplateModel parseTimeValue;
        String nameStr = name.image;
        if (nameStr.equals(ASTExpBuiltInVariable.OUTPUT_FORMAT)) {
            parseTimeValue = new SimpleScalar(outputFormat.getName());
        } else if (nameStr.equals(ASTExpBuiltInVariable.AUTO_ESC)) {
            parseTimeValue = autoEscaping ? TemplateBooleanModel.TRUE : TemplateBooleanModel.FALSE;
        } else {
            parseTimeValue = null;
        }
        
        result = new ASTExpBuiltInVariable(name, token_source, parseTimeValue);
        
        result.setLocation(template, dot, name);
        return result;
    }
}

/**
 * Production that builds up an expression
 * using the dot or dynamic key name
 * or the args list if this is a method invocation.
 */
ASTExpression AddSubExpression(ASTExpression exp) :
{
    ASTExpression result = null;
}
{
    (
        result = DotVariable(exp)
        |
        result = DynamicKey(exp)
        |
        result = MethodArgs(exp)
        |
        result = ASTExpBuiltIn(exp)
        |
        result = DefaultTo(exp)
        |
        result = Exists(exp)
    )
    {
        return result;
    }
}

ASTExpression DefaultTo(ASTExpression exp) :
{
    ASTExpression rhs = null;
    Token t;
}
{
    (
        t = <TERMINATING_EXCLAM>
        |
        (
            t = <EXCLAM>
            [
                LOOKAHEAD(ASTExpression())
                rhs = ASTExpression()
            ]
        )
    )
    {
        ASTExpDefault result = new ASTExpDefault(exp, rhs);
        if (rhs == null) {
            result.setLocation(template, exp, t);
        } else {
            result.setLocation(template, exp, rhs);
        }
        return result;
    }
}

ASTExpression Exists(ASTExpression exp) :
{
    Token t;
}
{
    t = <EXISTS>
    {
        ASTExpExists result = new ASTExpExists(exp);
        result.setLocation(template, exp, t);
        return result;
    }
}

ASTExpression ASTExpBuiltIn(ASTExpression lhoExp) :
{
    Token t = null;
    ASTExpBuiltIn result;
    ArrayList/*<ASTExpression>*/ args = null;
    Token openParen;
    Token closeParen;
}
{
    <BUILT_IN>
    t = <ID>
    {
        result = ASTExpBuiltIn.newBuiltIn(incompatibleImprovements, lhoExp, t, token_source);
        result.setLocation(template, lhoExp, t);
        
        if (!(result instanceof SpecialBuiltIn)) {
            return result;
        }

        if (result instanceof BuiltInForLoopVariable) {
            if (!(lhoExp instanceof ASTExpVariable)) {
                throw new ParseException(
                        "Expression used as the left hand operand of ?" + t.image
                        + " must be a simple loop variable name.", lhoExp);
            }
            String loopVarName = ((ASTExpVariable) lhoExp).getName();
            checkLoopVariableBuiltInLHO(loopVarName, lhoExp, t);
            ((BuiltInForLoopVariable) result).bindToLoopVariable(loopVarName);
            
            return result;
        }
        
        if (result instanceof BuiltInBannedWhenAutoEscaping) {
	        if (outputFormat instanceof MarkupOutputFormat && autoEscaping) {
	            throw new ParseException(
	                    "Using ?" + t.image + " (legacy escaping) is not allowed when auto-escaping is on with "
	                    + "a markup output format (" + outputFormat.getName() + "), to avoid double-escaping mistakes.",
	                    template, t);
	        }
            
            return result;
        }

        if (result instanceof MarkupOutputFormatBoundBuiltIn) {
            if (!(outputFormat instanceof MarkupOutputFormat)) {
                throw new ParseException(
                        "?" + t.image + " can't be used here, as the current output format isn't a markup (escaping) "
                        + "format: " + outputFormat, template, t);
            }
            ((MarkupOutputFormatBoundBuiltIn) result).bindToMarkupOutputFormat((MarkupOutputFormat) outputFormat);
            
            return result;
        }

        if (result instanceof OutputFormatBoundBuiltIn) {
            ((OutputFormatBoundBuiltIn) result).bindToOutputFormat(outputFormat, autoEscapingPolicy);
            
            return result;
        }
    }
    [
        LOOKAHEAD({ result instanceof BuiltInWithParseTimeParameters  })
        openParen = <OPEN_PAREN>
        args = PositionalArgs()
        closeParen = <CLOSE_PAREN> {
            result.setLocation(template, lhoExp, closeParen);
            ((BuiltInWithParseTimeParameters) result).bindToParameters(args, openParen, closeParen);
            
            return result;
        }
    ]
    {
        // Should have already return-ed
        throw new AssertionError("Unhandled " + SpecialBuiltIn.class.getName() + " subclass: " + result.getClass());
    }
}


/**
 * production for when a key is specified by <DOT> + keyname
 */
ASTExpression DotVariable(ASTExpression exp) :
{
    Token t;
}
{
        <DOT>
        (
            t = <ID> | t = <TIMES> | t = <DOUBLE_STAR> 
            |
            (
                t = <LESS_THAN>
                |
                t = <LESS_THAN_EQUALS>
                |
                t = <ESCAPED_GT>
                |
                t = <ESCAPED_GTE>
                |
                t = <FALSE>
                |
                t = <TRUE>
                |
                t = <IN>
                |
                t = <AS>
                |
                t = <USING>
            )
            {
                if (!Character.isLetter(t.image.charAt(0))) {
                    throw new ParseException(t.image + " is not a valid identifier.", template, t);
                }
            }
        )
        {
            notListLiteral(exp, "hash");
            notStringLiteral(exp, "hash");
            notBooleanLiteral(exp, "hash");
            ASTExpDot dot = new ASTExpDot(exp, t.image);
            dot.setLocation(template, exp, t);
            return dot;
        }
}

/**
 * production for when the key is specified
 * in brackets.
 */
ASTExpression DynamicKey(ASTExpression exp) :
{
    ASTExpression arg;
    Token t;
}
{
    <OPEN_BRACKET>
    arg = ASTExpression()
    t = <CLOSE_BRACKET>
    {
        notBooleanLiteral(exp, "list or hash");
        notNumberLiteral(exp, "list or hash");
        ASTExpDynamicKeyName dkn = new ASTExpDynamicKeyName(exp, arg);
        dkn.setLocation(template, exp, t);
        return dkn;
    }
}

/**
 * production for an arglist part of a method invocation.
 */
ASTExpMethodCall MethodArgs(ASTExpression exp) :
{
        ArrayList args = new ArrayList();
        Token end;
}
{
        <OPEN_PAREN>
        args = PositionalArgs()
        end = <CLOSE_PAREN>
        {
            args.trimToSize();
            ASTExpMethodCall result = new ASTExpMethodCall(exp, args);
            result.setLocation(template, exp, end);
            return result;
        }
}

ASTExpStringLiteral ASTExpStringLiteral(boolean interpolate) :
{
    Token t;
    boolean raw = false;
}
{
    (
        t = <STRING_LITERAL>
        |
        t = <RAW_STRING> { raw = true; }
    )
    {
        String s;
        // Get rid of the quotes.
        if (raw) {
            s = t.image.substring(2, t.image.length() -1);
        } else {
	        try {
	            s = FTLUtil.unescapeStringLiteralPart(t.image.substring(1, t.image.length() -1));
            } catch (GenericParseException e) {
                throw new ParseException(e.getMessage(), template, t);
            }
        }
        ASTExpStringLiteral result = new ASTExpStringLiteral(s);
        result.setLocation(template, t, t);
        if (interpolate && !raw) {
            // TODO: This logic is broken. It can't handle literals that contains both ${...} and $\{...}. 
            if (t.image.indexOf("${") >= 0) result.parseValue(token_source, outputFormat);
        }
        return result;
    }
}

ASTExpression ASTExpBooleanLiteral() :
{
    Token t;
    ASTExpression result;
}
{
    (
        t = <FALSE> { result = new ASTExpBooleanLiteral(false); }
        |
        t = <TRUE> { result = new ASTExpBooleanLiteral(true); }
    )
    {
        result.setLocation(template, t, t);
        return result;
    }
}


ASTExpHashLiteral ASTExpHashLiteral() :
{
    Token begin, end;
    ASTExpression key, value;
    ArrayList keys = new ArrayList();
    ArrayList values = new ArrayList();
}
{
    begin = <OPENING_CURLY_BRACKET>
    [
        key = ASTExpression()
        (<COMMA>|<COLON>)
        value = ASTExpression()
        {
            stringLiteralOnly(key);
            keys.add(key);
            values.add(value);
        }
        (
            <COMMA>
            key = ASTExpression()
            (<COMMA>|<COLON>)
            value = ASTExpression()
            {
                stringLiteralOnly(key);
                keys.add(key);
                values.add(value);
            }
        )*
    ]
    end = <CLOSING_CURLY_BRACKET>
    {
        ASTExpHashLiteral result = new ASTExpHashLiteral(keys, values);
        result.setLocation(template, begin, end);
        return result;
    }
}

/**
 * ${exp}
 */
ASTDollarInterpolation ASTDollarInterpolation() :
{
    ASTExpression exp;
    Token begin, end;
}
{
    begin = <DOLLAR_INTERPOLATION_OPENING>
    exp = ASTExpression()
    {
        notHashLiteral(exp, NonStringException.STRING_COERCABLE_TYPES_DESC);
        notListLiteral(exp, NonStringException.STRING_COERCABLE_TYPES_DESC);
    }
    end = <CLOSING_CURLY_BRACKET>
    {
        ASTDollarInterpolation result = new ASTDollarInterpolation(
                exp, escapedExpression(exp),
                outputFormat,
                autoEscaping);
        result.setLocation(template, begin, end);
        return result;
    }
}

ASTElement If() :
{
    Token start, end, t;
    ASTExpression condition;
    TemplateElements children;
    ASTDirIfElseIfElseContainer ifBlock;
    ASTDirIfOrElseOrElseIf cblock;
}
{
    start = <IF>
    condition = ASTExpression()
    end = <DIRECTIVE_END>
    children = MixedContentElements()
    {
        cblock = new ASTDirIfOrElseOrElseIf(condition, children, ASTDirIfOrElseOrElseIf.TYPE_IF);
        cblock.setLocation(template, start, end, children);
        ifBlock = new ASTDirIfElseIfElseContainer(cblock);
    }
    (
        t = <ELSE_IF>
        condition = ASTExpression()
        end = <DIRECTIVE_END>
        children = MixedContentElements()
        {
            cblock = new ASTDirIfOrElseOrElseIf(condition, children, ASTDirIfOrElseOrElseIf.TYPE_ELSE_IF);
            cblock.setLocation(template, t, end, children);
            ifBlock.addBlock(cblock);
        }
    )*
    [
            t = <ELSE>
            children = MixedContentElements()
            {
                cblock = new ASTDirIfOrElseOrElseIf(null, children, ASTDirIfOrElseOrElseIf.TYPE_ELSE);
                cblock.setLocation(template, t, t, children);
                ifBlock.addBlock(cblock);
            }
    ]
    end = <END_IF>
    {
        ifBlock.setLocation(template, start, end);
        return ifBlock;
    }
}

ASTDirAttemptRecoverContainer Attempt() :
{
    Token start, end;
    TemplateElements children;
    ASTDirRecover recoveryBlock;
}
{
    start = <ATTEMPT>
    children = MixedContentElements()
    recoveryBlock = Recover()
    end = <END_ATTEMPT>
    {
        ASTDirAttemptRecoverContainer result = new ASTDirAttemptRecoverContainer(children, recoveryBlock);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirRecover Recover() : 
{
    Token start;
    TemplateElements children;
}
{
    start = <RECOVER>
    children = MixedContentElements()
    {
        ASTDirRecover result = new ASTDirRecover(children);
        result.setLocation(template, start, start, children);
        return result;
    }
}

ASTElement List() :
{
    ASTExpression exp;
    Token loopVar = null, loopVar2 = null, start, end;
    TemplateElements childrendBeforeElse;
    ASTDirElseOfList elseOfList = null;
    ParserIteratorBlockContext iterCtx;
}
{
    start = <LIST>
    exp = ASTExpression()
    [
        <AS>
        loopVar = <ID>
        [
            <COMMA>
            loopVar2 = <ID>
        ]
    ]
    <DIRECTIVE_END>
    {
        iterCtx = pushIteratorBlockContext();
        if (loopVar != null) {
            iterCtx.loopVarName = loopVar.image;
            breakableDirectiveNesting++;
            if (loopVar2 != null) {
                iterCtx.loopVar2Name = loopVar2.image;
                iterCtx.hashListing = true;
                if (iterCtx.loopVar2Name.equals(iterCtx.loopVarName)) {
                    throw new ParseException(
                            "The key and value loop variable names must differ, but both were: " + iterCtx.loopVarName,
                            template, start);
                }
            }
        }
    }
    
    childrendBeforeElse = MixedContentElements()
    {
        if (loopVar != null) {
            breakableDirectiveNesting--;
        } else if (iterCtx.kind != ITERATOR_BLOCK_KIND_ITEMS) {
            throw new ParseException(
                    "#list must have either \"as loopVar\" parameter or nested #items that belongs to it.",
                    template, start);
        }
        popIteratorBlockContext();
    }
    
    [
        elseOfList = ASTDirElseOfList()
    ]
    
    end = <END_LIST>
    {
        ASTDirList list = new ASTDirList(
                exp,
                loopVar != null ? loopVar.image : null,  // null when we have a nested #items
                loopVar2 != null ? loopVar2.image : null,
                childrendBeforeElse, iterCtx.hashListing);
        list.setLocation(template, start, end);

        ASTElement result;
        if (elseOfList == null) {
            result = list;
        } else {
            result = new ASTDirListElseContainer(list, elseOfList);
            result.setLocation(template, start, end);
        }
        return result;
    }
}

ASTDirElseOfList ASTDirElseOfList() :
{
    Token start;
    TemplateElements children;
}
{
        start = <ELSE>
        children = MixedContentElements()
        {
            ASTDirElseOfList result = new ASTDirElseOfList(children);
	        result.setLocation(template, start, start, children);
	        return result;
        }
}

ASTDirItems Items() :
{
    Token loopVar, loopVar2 = null, start, end;
    TemplateElements children;
    ParserIteratorBlockContext iterCtx;
}
{
    start = <ITEMS>
    loopVar = <ID>
    [
        <COMMA>
        loopVar2 = <ID>
    ]
    <DIRECTIVE_END>
    {
        iterCtx = peekIteratorBlockContext();
        if (iterCtx == null) {
            throw new ParseException("#items must be inside a #list block.", template, start);
        }
        if (iterCtx.loopVarName != null) {
            String msg;
	        if (iterCtx.kind == ITERATOR_BLOCK_KIND_ITEMS) {
                msg = "Can't nest #items into each other when they belong to the same #list.";
	        } else {
	            msg = "The parent #list of the #items must not have \"as loopVar\" parameter.";
            }
            throw new ParseException(msg, template, start);
        }
        iterCtx.kind = ITERATOR_BLOCK_KIND_ITEMS;
        iterCtx.loopVarName = loopVar.image;
        if (loopVar2 != null) {
            iterCtx.loopVar2Name = loopVar2.image;
            iterCtx.hashListing = true;
            if (iterCtx.loopVar2Name.equals(iterCtx.loopVarName)) {
                throw new ParseException(
                        "The key and value loop variable names must differ, but both were: " + iterCtx.loopVarName,
                        template, start);
            }
        }
    
        breakableDirectiveNesting++;
    }
    
    children = MixedContentElements()
    
    end = <END_ITEMS>
    {
        breakableDirectiveNesting--;
        iterCtx.loopVarName = null;
        iterCtx.loopVar2Name = null;
        
        ASTDirItems result = new ASTDirItems(loopVar.image, loopVar2 != null ? loopVar2.image : null, children);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirSep Sep() :
{
    Token loopVar, start, end = null;
    TemplateElements children;
}
{
    start = <SEP>
    {
        if (peekIteratorBlockContext() == null) {
            throw new ParseException(
                    "#sep must be inside a #list block.",
                    template, start);
        }
    }
    children = MixedContentElements()
    [
        LOOKAHEAD(1)
        end = <END_SEP>
    ]
    {
        ASTDirSep result = new ASTDirSep(children);
        if (end != null) {
            result.setLocation(template, start, end);
        } else {
            result.setLocation(template, start, start, children);
        }
        return result;
    }
}

ASTDirVisit Visit() :
{
    Token start, end;
    ASTExpression targetNode, namespaces = null;
}
{
    start = <VISIT>
    targetNode = ASTExpression()
    [
        <USING>
        namespaces = ASTExpression()
    ]
    end = LooseDirectiveEnd()
    {
        ASTDirVisit result = new ASTDirVisit(targetNode, namespaces);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirRecurse Recurse() :
{
    Token start, end = null;
    ASTExpression node = null, namespaces = null;
}
{
    (
        start = <SIMPLE_RECURSE>
        |
        (
            start = <RECURSE>
            [
                node = ASTExpression()
            ]
            [
                <USING>
                namespaces = ASTExpression()
            ]
            end = LooseDirectiveEnd()
        )
    )
    {
        if (end == null) end = start;
        ASTDirRecurse result = new ASTDirRecurse(node, namespaces);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirFallback FallBack() :
{
    Token tok;
}
{
    tok = <FALLBACK>
    {
        if (!inMacro) {
            throw new ParseException("Cannot fall back outside a macro.", template, tok);
        }
        ASTDirFallback result = new ASTDirFallback();
        result.setLocation(template, tok, tok);
        return result;
    }
}

/**
 * Production used to break out of a loop or a switch block.
 */
ASTDirBreak Break() :
{
    Token start;
}
{
    start = <BREAK>
    {
        if (breakableDirectiveNesting < 1) {
            throw new ParseException(start.image + " must be nested inside a directive that supports it: " 
                    + " #list with \"as\", #items, #switch",
                    template, start);
        }
        ASTDirBreak result = new ASTDirBreak();
        result.setLocation(template, start, start);
        return result;
    }
}

/**
 * Production used to jump out of a macro.
 * The stop instruction terminates the rendering of the template.
 */
ASTDirReturn Return() :
{
    Token start, end = null;
    ASTExpression exp = null;
}
{
    (
        start = <SIMPLE_RETURN> { end = start; }
        |
        start = <RETURN> exp = ASTExpression() end = LooseDirectiveEnd()
    )
    {
        if (inMacro) {
            if (exp != null) {
            	throw new ParseException("A macro cannot return a value", template, start);
            }
        } else if (inFunction) {
            if (exp == null) {
            	throw new ParseException("A function must return a value", template, start);
            }
        } else {
            if (exp == null) {
            	throw new ParseException(
            			"A return instruction can only occur inside a macro or function", template, start);
            }
        }
        ASTDirReturn result = new ASTDirReturn(exp);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirStop Stop() :
{
    Token start = null;
    ASTExpression exp = null;
}
{
    (
        start = <HALT>
        |
        start = <STOP> exp = ASTExpression() LooseDirectiveEnd()
    )
    {
        ASTDirStop result = new ASTDirStop(exp);
        result.setLocation(template, start, start);
        return result;
    }
}

ASTElement Nested() :
{
    Token t, end;
    ArrayList bodyParameters;
    ASTDirNested result = null;
}
{
    (
        (
            t = <SIMPLE_NESTED>
            {
                result = new ASTDirNested(null);
                result.setLocation(template, t, t);
            }
        )
        |
        (
            t = <NESTED>
            bodyParameters = PositionalArgs()
            end = LooseDirectiveEnd()
            {
                result = new ASTDirNested(bodyParameters);
                result.setLocation(template, t, end);
            }
        )
    )
    {
        if (!inMacro) {
            throw new ParseException("Cannot use a " + t.image + " instruction outside a macro.", template, t);
        }
        return result;
    }
}

ASTElement Flush() :
{
    Token t;
}
{
    t = <FLUSH>
    {
        ASTDirFlush result = new ASTDirFlush();
        result.setLocation(template, t, t);
        return result;
    }
}

ASTElement Trim() :
{
    Token t;
    ASTDirTOrRtOrLtOrNt result = null;
}
{
    (
        t = <TRIM> { result = new ASTDirTOrRtOrLtOrNt(true, true); }
        |
        t = <LTRIM> { result = new ASTDirTOrRtOrLtOrNt(true, false); }
        |
        t = <RTRIM> { result = new ASTDirTOrRtOrLtOrNt(false, true); }
        |
        t = <NOTRIM> { result = new ASTDirTOrRtOrLtOrNt(false, false); }
    )
    {
        result.setLocation(template, t, t);
        return result;
    }
}


ASTElement Assign() :
{
    Token start, end;
    int scope;
    Token id = null;
    Token equalsOp;
    ASTExpression nameExp, exp, nsExp = null;
    String varName;
    ArrayList assignments = new ArrayList();
    ASTDirAssignment ass;
    TemplateElements children;
}
{
    (
        start = <ASSIGN> { scope = ASTDirAssignment.NAMESPACE; }
        |
        start = <GLOBALASSIGN> { scope = ASTDirAssignment.GLOBAL; }
        |
        start = <LOCALASSIGN> { scope = ASTDirAssignment.LOCAL; }
        {
            scope = ASTDirAssignment.LOCAL;
            if (!inMacro && !inFunction) {
                throw new ParseException("Local variable assigned outside a macro.", template, start);
            }
        }
    )
    nameExp = IdentifierOrStringLiteral()
    {
        varName = (nameExp instanceof ASTExpStringLiteral)
                ? ((ASTExpStringLiteral) nameExp).getAsString()
                : ((ASTExpVariable) nameExp).getName();
    }
    (
    	(
            (
	    	    (
			        (<ASSIGNMENT_EQUALS>|<PLUS_EQUALS>|<MINUS_EQUALS>|<TIMES_EQUALS>|<DIV_EQUALS>|<MOD_EQUALS>)
			        {
			           equalsOp = token;
			        }
			        exp = ASTExpression()
		        )
		        |
		        (
	                (<PLUS_PLUS>|<MINUS_MINUS>)
	                {
	                   equalsOp = token;
	                   exp = null;
	                }
		        )
	        )
	        {
	            ass = new ASTDirAssignment(varName, equalsOp.kind, exp, scope);
                if (exp != null) {
                   ass.setLocation(template, nameExp, exp);
                } else {
                   ass.setLocation(template, nameExp, equalsOp);
                }
	            assignments.add(ass);
	        }
	        (
	            LOOKAHEAD(
	               [<COMMA>]
	               (<ID>|<STRING_LITERAL>)
	               (<ASSIGNMENT_EQUALS>|<PLUS_EQUALS>|<MINUS_EQUALS>|<TIMES_EQUALS>|<DIV_EQUALS>|<MOD_EQUALS>
	                       |<PLUS_PLUS>|<MINUS_MINUS>)
	            )
	            [<COMMA>]
	            nameExp = IdentifierOrStringLiteral()
	            {
	                varName = (nameExp instanceof ASTExpStringLiteral)
	                		? ((ASTExpStringLiteral) nameExp).getAsString()
	                		: ((ASTExpVariable) nameExp).getName();
	            }
	            (
	                (
	                    (<ASSIGNMENT_EQUALS>|<PLUS_EQUALS>|<MINUS_EQUALS>|<TIMES_EQUALS>|<DIV_EQUALS>|<MOD_EQUALS>)
	                    {
	                       equalsOp = token;
	                    }
	                    exp = ASTExpression()
	                )
	                |
	                (
	                    (<PLUS_PLUS>|<MINUS_MINUS>)
	                    {
	                       equalsOp = token;
	                       exp = null;
	                    }
	                )
	            )
	            {
	                ass = new ASTDirAssignment(varName, equalsOp.kind, exp, scope);
	                if (exp != null) {
	                   ass.setLocation(template, nameExp, exp);
	                } else {
                       ass.setLocation(template, nameExp, equalsOp);
	                }
	                assignments.add(ass);
	            } 
	        )*
	        [
	            id = <IN>
	            nsExp = ASTExpression()
	            {
	                if (scope != ASTDirAssignment.NAMESPACE) {
	                	throw new ParseException("Cannot assign to namespace here.", template, id);
                	}
	            }
	        ]
	        end = LooseDirectiveEnd()
	        {
                if (assignments.size() == 1) {
                    ASTDirAssignment a = (ASTDirAssignment) assignments.get(0);
                    a.setNamespaceExp(nsExp);
                    a.setLocation(template, start, end);
                    return a;
                } else {
		            ASTDirAssignmentsContainer ai = new ASTDirAssignmentsContainer(scope);
		            for (int i = 0; i< assignments.size(); i++) {
		                ai.addAssignment((ASTDirAssignment) assignments.get(i));
		            }
		            ai.setNamespaceExp(nsExp);
		            ai.setLocation(template, start, end);
		            return ai;
	            }
	        }
	    )
	    |
	    (
	        [
	            id = <IN>
	            nsExp = ASTExpression()
	            {
	                if (scope != ASTDirAssignment.NAMESPACE) {
	                	throw new ParseException("Cannot assign to namespace here.", template, id);
	            	}
	            }
	        ]
	        <DIRECTIVE_END>
	        children = MixedContentElements()
	        (
	            end = <END_LOCAL>
	            {
	            	if (scope != ASTDirAssignment.LOCAL) {
	            		throw new ParseException("Mismatched assignment tags.", template, end);
	        		}
	        	}
	            |
	            end = <END_ASSIGN>
	            {
	            	if (scope != ASTDirAssignment.NAMESPACE) {
	            		throw new ParseException("Mismatched assignment tags.", template, end);
	        		}
	        	}
	            |
	            end = <END_GLOBAL>
	            {
	            	if (scope != ASTDirAssignment.GLOBAL) throw new ParseException(
	            			"Mismatched assignment tags", template, end);
            	}
	        )
	        {
	            ASTDirCapturingAssignment ba = new ASTDirCapturingAssignment(
	                   children, varName, scope, nsExp,
	                   getMarkupOutputFormat());
	            ba.setLocation(template, start, end);
	            return ba;
	        }
	    )
    )
}

ASTDirInclude Include() :
{
    ASTExpression nameExp;
    Token att, start, end;
    ASTExpression exp, ignoreMissingExp = null;
}
{
    start = <_INCLUDE>
    nameExp = ASTExpression()
    [<SEMICOLON>]
    (
        att = <ID>
        <ASSIGNMENT_EQUALS>
        exp = ASTExpression()
        {
            String attString = att.image;
            if (attString.equalsIgnoreCase("ignore_missing") || attString.equals("ignoreMissing")) {
            	ignoreMissingExp = exp;
            } else {
                String correctedName = attString.equals("ignoreMissing") ? "ignore_missing" : null;
                throw new ParseException(
                		"Unsupported named #include parameter: \"" + attString + "\". Supported parameters are: "
                		+ "\"ignore_missing\"."
                		+ (correctedName == null
                		      ? ""
                		      : " Supporting camelCase parameter names is planned for FreeMarker 2.4.0; "
	                              + "check if an update is available, and if it indeed supports camel "
	                              + "case."),
                		template, att);
            }
        }
    )*
    end = LooseDirectiveEnd()
    {
        ASTDirInclude result = new ASTDirInclude(template, nameExp, ignoreMissingExp);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirImport Import() :
{
    Token start, end, ns;
    ASTExpression nameExp;
}
{
    start = <IMPORT>
    nameExp = ASTExpression()
    <AS>
    ns = <ID>
    end = LooseDirectiveEnd()
    {
        ASTDirImport result = new ASTDirImport(template, nameExp, ns.image);
        result.setLocation(template, start, end);
        template.addImport(result);
        return result;
    }
}

ASTDirMacro Macro() :
{
    Token arg, start, end;
    ASTExpression nameExp;
    String name;
    ArrayList argNames = new ArrayList();
    HashMap args = new HashMap();
    ArrayList defNames = new ArrayList();
    ASTExpression defValue = null;
    List lastIteratorBlockContexts;
    int lastBreakableDirectiveNesting;
    TemplateElements children;
    boolean isFunction = false, hasDefaults = false;
    boolean isCatchAll = false;
    String catchAll = null;
}
{
    (
        start = <MACRO>
        |
        start = <FUNCTION> { isFunction = true; }
    )
    {
        if (inMacro || inFunction) {
            throw new ParseException("Macros cannot be nested.", template, start);
        }
        if (isFunction) inFunction = true; else inMacro = true;
    }
    nameExp = IdentifierOrStringLiteral()
    {
        name = (nameExp instanceof ASTExpStringLiteral)
                ? ((ASTExpStringLiteral) nameExp).getAsString()
                : ((ASTExpVariable) nameExp).getName();
    }
    [<OPEN_PAREN>]
    (
        arg = <ID> { defValue = null; }
        [
            <ELLIPSIS> { isCatchAll = true; }
        ]
        [
            <ASSIGNMENT_EQUALS>
            defValue = ASTExpression()
            {
                defNames.add(arg.image);
                hasDefaults = true;
            }
        ]
        [<COMMA>]
        {
            if (catchAll != null) {
                throw new ParseException(
                "There may only be one \"catch-all\" parameter in a macro declaration, and it must be the last parameter.",
                template, arg);
            }
            if (isCatchAll) {
                if (defValue != null) {
                    throw new ParseException(
                    "\"Catch-all\" macro parameter may not have a default value.",
                    template, arg);
                }
                catchAll = arg.image;
            } else {
                argNames.add(arg.image);
                if (hasDefaults && defValue == null) {
                    throw new ParseException(
		                    "In a macro declaration, parameters without a default value "
		                    + "must all occur before the parameters with default values.",
                    template, arg);
                }
                args.put(arg.image, defValue);
            }
        }
    )*
    [<CLOSE_PAREN>]
    <DIRECTIVE_END>
    {
        // To prevent parser check loopholes like <#list ...><#macro ...><#break></#macro></#list>.
        lastIteratorBlockContexts = iteratorBlockContexts;
        iteratorBlockContexts = null;
        lastBreakableDirectiveNesting = breakableDirectiveNesting;
        breakableDirectiveNesting = 0; 
    }
    children = MixedContentElements()
    (
        end = <END_MACRO>
        {
        	if (isFunction) throw new ParseException("Expected function end tag here.", template, start);
    	}
        |
        end = <END_FUNCTION>
        {
    		if (!isFunction) throw new ParseException("Expected macro end tag here.", template, start);
    	}
    )
    {
        iteratorBlockContexts = lastIteratorBlockContexts;
        breakableDirectiveNesting = lastBreakableDirectiveNesting;
        
        inMacro = inFunction = false;
        ASTDirMacro result = new ASTDirMacro(name, argNames, args, catchAll, isFunction, children);
        result.setLocation(template, start, end);
        template.addMacro(result);
        return result;
    }
}

ASTDirCompress Compress() :
{
    TemplateElements children;
    Token start, end;
}
{
    start = <COMPRESS>
    children = MixedContentElements()
    end = <END_COMPRESS>
    {
        ASTDirCompress cb = new ASTDirCompress(children);
        cb.setLocation(template, start, end);
        return cb;
    }
}

ASTElement UnifiedMacroTransform() :
{
    Token start = null, end, t;
    HashMap namedArgs = null;
    ArrayList positionalArgs = null, bodyParameters = null;
    ASTExpression startTagNameExp;
    TemplateElements children;
    ASTExpression exp;
    int pushedCtxCount = 0;
}
{
    start = <UNIFIED_CALL>
    exp = ASTExpression()
    {
        if (exp instanceof ASTExpVariable || (exp instanceof ASTExpDot && ((ASTExpDot) exp).onlyHasIdentifiers())) {
            startTagNameExp = exp;
        } else {
            startTagNameExp = null;
        }
    }
    [<TERMINATING_WHITESPACE>]
    (
        LOOKAHEAD(<ID><ASSIGNMENT_EQUALS>)
        namedArgs = NamedArgs()
        |
        positionalArgs = PositionalArgs()
    )
    [
        <SEMICOLON>{bodyParameters = new ArrayList(4); }
        [
            [<TERMINATING_WHITESPACE>] t = <ID> { bodyParameters.add(t.image); }
            (
                [<TERMINATING_WHITESPACE>] <COMMA>
                [<TERMINATING_WHITESPACE>] t = <ID>{bodyParameters.add(t.image); }
            )*
        ]
    ]
    (
        end = <EMPTY_DIRECTIVE_END> { children = TemplateElements.EMPTY; }
        |
        (
            <DIRECTIVE_END> {
                if (bodyParameters != null && iteratorBlockContexts != null && !iteratorBlockContexts.isEmpty()) {
                    // It's possible that we shadow a #list/#items loop variable, in which case that must be noted.
                    int ctxsLen = iteratorBlockContexts.size();
                    int bodyParsLen = bodyParameters.size();
	                for (int bodyParIdx = 0; bodyParIdx < bodyParsLen; bodyParIdx++) {
                        String bodyParName = (String) bodyParameters.get(bodyParIdx);
                        walkCtxSack: for (int ctxIdx = ctxsLen - 1; ctxIdx >= 0; ctxIdx--) {
                            ParserIteratorBlockContext ctx
                                    = (ParserIteratorBlockContext) iteratorBlockContexts.get(ctxIdx);
                            if (ctx.loopVarName != null && ctx.loopVarName.equals(bodyParName)) {
                                // If it wasn't already shadowed, shadow it:
                                if (ctx.kind != ITERATOR_BLOCK_KIND_USER_DIRECTIVE) {
                                    ParserIteratorBlockContext shadowingCtx = pushIteratorBlockContext();
                                    shadowingCtx.loopVarName = bodyParName;
                                    shadowingCtx.kind = ITERATOR_BLOCK_KIND_USER_DIRECTIVE;
                                    pushedCtxCount++;
                                }
                                break walkCtxSack;
                            }
                        }
                   }
                }
            }
            children = MixedContentElements()
            end = <UNIFIED_CALL_END>
            {
                for (int i = 0; i < pushedCtxCount; i++) {
                    popIteratorBlockContext();
                }
            
                String endTagName = end.image.substring(3, end.image.length() - 1).trim();
                if (endTagName.length() > 0) {
                    if (startTagNameExp == null) {
                        throw new ParseException("Expecting </@>", template, end);
                    } else {
                        String startTagName = startTagNameExp.getCanonicalForm();
                        if (!endTagName.equals(startTagName)) {
                            throw new ParseException("Expecting </@> or </@" + startTagName + ">", template, end);
                        }
                    }
                }
            }
        )
    )
    {
        ASTElement result = (positionalArgs != null)
        		? new ASTDirUserDefined(exp, positionalArgs, children, bodyParameters)
	            : new ASTDirUserDefined(exp, namedArgs, children, bodyParameters);
        result.setLocation(template, start, end);
        return result;
    }
}

HashMap NamedArgs() :
{
    HashMap result = new HashMap();
    Token t;
    ASTExpression exp;
}
{
    (
        t = <ID>
        <ASSIGNMENT_EQUALS>
        {
            token_source.SwitchTo(token_source.NAMED_PARAMETER_EXPRESSION);
            token_source.inInvocation = true;
        }             
        exp = ASTExpression()
        {
            result.put(t.image, exp);
        }
    )+
    {
        token_source.inInvocation = false;
        return result;
    }
}

ArrayList PositionalArgs() :
{
    ArrayList result = new ArrayList();
    ASTExpression arg;
}
{
    [
        arg = ASTExpression() { result.add(arg); }
        (
            <COMMA>
            arg = ASTExpression() { result.add(arg); }
        )*
    ]
    {
        return result;
    }
}


ASTComment Comment() :
{
    Token start, end;
    StringBuilder buf = new StringBuilder();
}
{
    (
        start = <TERSE_COMMENT>
    )
    end = UnparsedContent(start, buf)
    {
        ASTComment result = new ASTComment(buf.toString());
        result.setLocation(template, start, end);
        return result;
    }
}

ASTStaticText NoParse() :
{
    Token start, end;
    StringBuilder buf = new StringBuilder();
}
{
    start = <NOPARSE>
    end = UnparsedContent(start, buf)
    {
        ASTStaticText result = new ASTStaticText(buf.toString(), true);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirSwitch Switch() :
{
    ASTDirSwitch switchBlock;
    ASTImplicitParent ignoredSectionBeforeFirstCase = null;
    ASTDirCase caseOrDefault;
    ASTExpression switchExp;
    Token start, end;
    boolean defaultFound = false;
}
{
    (
	    start = <SWITCH>
	    switchExp = ASTExpression()
	    <DIRECTIVE_END>
        [ ignoredSectionBeforeFirstCase = WhitespaceAndComments() ]
    )
    {
        breakableDirectiveNesting++;
        switchBlock = new ASTDirSwitch(switchExp, ignoredSectionBeforeFirstCase);
    }
    (
        LOOKAHEAD(2)
        caseOrDefault = ASTDirCase()
        {
            if (caseOrDefault.condition == null) {
                if (defaultFound) {
                    throw new ParseException(
                            "You can only have one default case in a switch statement", template, start);
                }
                defaultFound = true;
            } else if (defaultFound) {
                    throw new ParseException(
                            "You can't have a \"case\" directive after the \"default\" directive",
                            caseOrDefault);
            }
            switchBlock.addCase(caseOrDefault);
        }
    )*
    [<STATIC_TEXT_WS>]
    end = <END_SWITCH>
    {
        breakableDirectiveNesting--;
        switchBlock.setLocation(template, start, end);
        return switchBlock;
    }
}

ASTDirCase ASTDirCase() :
{
    ASTExpression exp;
    TemplateElements children;
    Token start;
}
{
    (
        start = <CASE> exp = ASTExpression() <DIRECTIVE_END>
        |
        start = <DEFAUL> { exp = null; }
    )
    children = MixedContentElements()
    {
        ASTDirCase result = new ASTDirCase(exp, children);
        result.setLocation(template, start, start, children);
        return result;
    }
}

ASTDirEscape Escape() :
{
    Token variable, start, end;
    ASTExpression escapeExpr;
    TemplateElements children;
}
{
    start = <ESCAPE>
    {
        if (outputFormat instanceof MarkupOutputFormat && autoEscaping) {
            throw new ParseException(
                    "Using the \"escape\" directive (legacy escaping) is not allowed when auto-escaping is on with "
                    + "a markup output format (" + outputFormat.getName()
                    + "), to avoid confusion and double-escaping mistakes.",
                    template, start);
        }
    }
    variable = <ID>
    <AS>
    escapeExpr = ASTExpression()
    <DIRECTIVE_END>
    {
        ASTDirEscape result = new ASTDirEscape(variable.image, escapeExpr, escapedExpression(escapeExpr));
        escapes.addFirst(result);
    }
    children = MixedContentElements()
    {
        result.setContent(children);
        escapes.removeFirst();
    }
    end = <END_ESCAPE>
    {
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirNoEscape NoEscape() :
{
    Token start, end;
    TemplateElements children;
}
{
    start = <NOESCAPE>
    {
        if (escapes.isEmpty()) {
            throw new ParseException("#noEscape with no matching #escape encountered.", template, start);
        }
        Object escape = escapes.removeFirst();
    }
    children = MixedContentElements()
    end = <END_NOESCAPE>
    {
        escapes.addFirst(escape);
        ASTDirNoEscape result = new ASTDirNoEscape(children);
        result.setLocation(template, start, end);
        return result;
    }
}

ASTDirOutputFormat OutputFormat() :
{
    Token start, end;
    ASTExpression paramExp;
    TemplateElements children;
    OutputFormat lastOutputFormat;
}
{
    start = <OUTPUTFORMAT>
    paramExp = ASTExpression()
    <DIRECTIVE_END>
    {
        if (!paramExp.isLiteral()) {
            throw new ParseException(
                    "Parameter expression must be parse-time evaluable (constant): "
                    + paramExp.getCanonicalForm(),
                    paramExp);
        }
    
        TemplateModel paramTM;
        try {
            paramTM = paramExp.eval(null);
        } catch (Exception e) {
            throw new ParseException(
                    "Could not evaluate expression (on parse-time): " + paramExp.getCanonicalForm()
                    + "\nUnderlying cause: " +  e,
                    paramExp, e);
        }
        String paramStr;
        if (paramTM instanceof TemplateScalarModel) {
            try {
                paramStr = ((TemplateScalarModel) paramTM).getAsString();
            } catch (TemplateModelException e) {
	            throw new ParseException(
	                    "Could not evaluate expression (on parse-time): " + paramExp.getCanonicalForm()
	                    + "\nUnderlying cause: " +  e,
	                    paramExp, e);
            }
        } else {
            throw new ParseException(
                    "Parameter must be a string, but was: " + FTLUtil.getTypeDescription(paramTM),
                    paramExp);
        }
        
        lastOutputFormat = outputFormat;
        try { 
            if (paramStr.startsWith("{")) {
                if (!paramStr.endsWith("}")) {
                    throw new ParseException("Output format name that starts with '{' must end with '}': " + paramStr,
                            template, start);
                }
                OutputFormat innerOutputFormat = template.getConfiguration().getOutputFormat(
                        paramStr.substring(1, paramStr.length() - 1));
                if (!(innerOutputFormat instanceof MarkupOutputFormat)) {
                    throw new ParseException(
                            "The output format inside the {...} must be a markup format, but was: "
                            + innerOutputFormat,
                            template, start);
                }
                if (!(outputFormat instanceof MarkupOutputFormat)) {
                    throw new ParseException(
                            "The current output format must be a markup format when using {...}, but was: "
                            + outputFormat,
                            template, start);
                }
                outputFormat = new CombinedMarkupOutputFormat(
                        (MarkupOutputFormat) outputFormat, (MarkupOutputFormat) innerOutputFormat);
            } else {
                outputFormat = template.getConfiguration().getOutputFormat(paramStr);
            }
            recalculateAutoEscapingField();
        } catch (IllegalArgumentException e) {
            throw new ParseException("Invalid format name: " + e.getMessage(), template, start, e.getCause());
        } catch (UnregisteredOutputFormatException e) {
            throw new ParseException(e.getMessage(), template, start, e.getCause());
        }
    }
    children = MixedContentElements()
    end = <END_OUTPUTFORMAT>
    {
        ASTDirOutputFormat result = new ASTDirOutputFormat(children, paramExp);
        result.setLocation(template, start, end);
        
        outputFormat = lastOutputFormat;
        recalculateAutoEscapingField();         
        return result;
    }
}

ASTDirAutoEsc AutoEsc() :
{
    Token start, end;
    TemplateElements children;
    AutoEscapingPolicy lastAutoEscapingPolicy;
}
{
    start = <AUTOESC>
    {
        checkCurrentOutputFormatCanEscape(start);
        lastAutoEscapingPolicy = autoEscapingPolicy;
        autoEscapingPolicy = AutoEscapingPolicy.ENABLE_IF_SUPPORTED;
        recalculateAutoEscapingField();
    }
    children = MixedContentElements()
    end = <END_AUTOESC>
    {
        ASTDirAutoEsc result = new ASTDirAutoEsc(children);
        result.setLocation(template, start, end);
        
        autoEscapingPolicy = lastAutoEscapingPolicy; 
        recalculateAutoEscapingField();
        return result;
    }
}

ASTDirNoAutoEsc NoAutoEsc() :
{
    Token start, end;
    TemplateElements children;
    AutoEscapingPolicy lastAutoEscapingPolicy;
}
{
    start = <NOAUTOESC>
    {
        lastAutoEscapingPolicy = autoEscapingPolicy;
        autoEscapingPolicy = AutoEscapingPolicy.DISABLE;
        recalculateAutoEscapingField();
    }
    children = MixedContentElements()
    end = <END_NOAUTOESC>
    {
        ASTDirNoAutoEsc result = new ASTDirNoAutoEsc(children);
        result.setLocation(template, start, end);
        
        autoEscapingPolicy = lastAutoEscapingPolicy;
        recalculateAutoEscapingField(); 
        return result;
    }
}

/**
 * Production to terminate potentially empty elements. Either a ">" or "/>"
 */
Token LooseDirectiveEnd() :
{
    Token t;
}
{
    (
        t = <DIRECTIVE_END>
        |
        t = <EMPTY_DIRECTIVE_END>
    )
    {
        return t;
    }
}

ASTDirSetting Setting() :
{
    Token start, end, key;
    ASTExpression value;
}
{
    start = <SETTING>
    key = <ID>
    <ASSIGNMENT_EQUALS>
    value = ASTExpression()
    end = LooseDirectiveEnd()
    {
        ASTDirSetting result = new ASTDirSetting(key, token_source, value, template.getConfiguration());
        result.setLocation(template, start, end);
        return result;
    }
}

/**
 * A production for FreeMarker directives.
 */
ASTElement FreemarkerDirective() :
{
    ASTElement tp;
}
{
    // Note that this doesn't include elements like "else", "recover", etc., because those indicate the end
    // of the MixedContentElements of "if", "attempt", etc.
    (
        tp = If()
        |
        tp = List()
        |
        tp = Assign()
        |
        tp = Include()
        |
        tp = Import()
        |
        tp = Macro()
        |
        tp = Compress()
        |
        tp = UnifiedMacroTransform()
        |
        tp = Items()
        |
        tp = Sep()
        |
        tp = Comment()
        |
        tp = NoParse()
        |
        tp = Switch()
        |
        tp = Setting()
        |
        tp = Break()
        |
        tp = Return()
        |
        tp = Stop()
        |
        tp = Flush()
        |
        tp = Trim()
        |
        tp = Nested()
        |
        tp = Escape()
        |
        tp = NoEscape()
        |
        tp = Visit()
        |
        tp = Recurse()
        |
        tp = FallBack()
        |
        tp = Attempt()
        |
        tp = OutputFormat()
        |
        tp = AutoEsc()
        |
        tp = NoAutoEsc()
    )
    {
        return tp;
    }
}

/**
 * Production for a block of raw text
 * i.e. text that contains no
 * FreeMarker directives.
 */
ASTStaticText PCData() :
{
    StringBuilder buf = new StringBuilder();
    Token t = null, start = null, prevToken = null;
}
{
    (
        (
            t = <STATIC_TEXT_WS>
            |
            t = <STATIC_TEXT_NON_WS>
            |
            t = <STATIC_TEXT_FALSE_ALARM>
        )
        {
            buf.append(t.image);
            if (start == null) start = t;
            if (prevToken != null) prevToken.next = null;
            prevToken = t;
        }
    )+
    {
        if (stripText && mixedContentNesting == 1) return null;

        ASTStaticText result = new ASTStaticText(buf.toString(), false);
        result.setLocation(template, start, t);
        return result;
    }
}

ASTStaticText WhitespaceText() :
{
    Token t = null, start = null;
}
{
    t = <STATIC_TEXT_WS>
    {
        if (stripText && mixedContentNesting == 1) return null;

        ASTStaticText result = new ASTStaticText(t.image, false);
        result.setLocation(template, t, t);
        return result;
    }
}

/**
 * Production for dealing with unparsed content,
 * i.e. what is inside a comment or noParse tag.
 * It returns the ending token. The content
 * of the tag is put in buf.
 */
Token UnparsedContent(Token start, StringBuilder buf) :
{
    Token t;
}
{
    (
        (t = <KEEP_GOING> | t = <MAYBE_END> | t = <TERSE_COMMENT_END> | t = <LONE_LESS_THAN_OR_DASH>)
        {
            buf.append(t.image);
        }
    )+
    {
        buf.setLength(buf.length() - t.image.length());
        if (!t.image.endsWith(";")) {
            throw new ParseException("Unclosed \"" + start.image + "\"", template, start);
        }
        return t;
    }
}

TemplateElements MixedContentElements() :
{
    ASTElement[] childBuffer = null;
    int childCount = 0;
    ASTElement elem;
    mixedContentNesting++;
}
{
    (
        LOOKAHEAD(1) // Just tells javacc that we know what we're doing.
        (
            elem = PCData()
            |
            elem = ASTDollarInterpolation()
            |
            elem = FreemarkerDirective()
        )
        {
            // Note: elem == null when it's was top-level PCData removed by stripText
            if (elem != null) {
	            childCount++;
	            if (childBuffer == null) {
	                childBuffer = new ASTElement[16]; 
	            } else if (childBuffer.length < childCount) {
	                ASTElement[] newChildBuffer = new ASTElement[childCount * 2];
	                for (int i = 0; i < childBuffer.length; i++) {
	                    newChildBuffer[i] = childBuffer[i];
	                }
	                childBuffer = newChildBuffer;
	            }
	            childBuffer[childCount - 1] = elem;
            }
        }
    )*
    {
        mixedContentNesting--;
        return childBuffer != null ? new TemplateElements(childBuffer, childCount) : TemplateElements.EMPTY;
    }
}

/**
 * Not used anymore; kept for backward compatibility.
 *
 * @deprecated Use {@link #MixedContentElements} instead.
 */
ASTImplicitParent ASTImplicitParent() :
{
    ASTImplicitParent mixedContent = new ASTImplicitParent();
    ASTElement elem, begin = null;
    mixedContentNesting++;
}
{
    (
        LOOKAHEAD(1) // Just tells javacc that we know what we're doing.
        (
            elem = PCData()
            |
            elem = ASTDollarInterpolation()
            |
            elem = FreemarkerDirective()
        )
        {
            if (begin == null) {
                begin = elem;
            }
            mixedContent.addChild(elem);
        }
    )+
    {
        mixedContentNesting--;
        mixedContent.setLocation(template, begin, elem);
        return mixedContent;
    }
}

/**
 * Not used anymore; kept for backward compatibility.
 *
 * <p>A production for a block of optional content.
 * Returns an empty Text block if there is no
 * content.
 *
 * @deprecated Use {@link #MixedContentElements} instead.
 */
ASTElement OptionalBlock() :
{
    ASTElement tp = null;
}
{
    [
        LOOKAHEAD(1) // has no effect but to get rid of a spurious warning.
        tp = ASTImplicitParent()
    ]
    {
        return tp != null ? tp : new ASTStaticText(_CollectionUtil.EMPTY_CHAR_ARRAY, false);
    }
}

/**
 * A production freemarker text that may contain ${...}, but no directives.
 */
ASTElement FreeMarkerText() :
{
    ASTImplicitParent nodes = new ASTImplicitParent();
    ASTElement elem, begin = null;
}
{
    (
        (
            elem = PCData()
            |
            elem = ASTDollarInterpolation()  // Find related: [interpolation prefixes]
        )
        {
            if (begin == null) {
            	begin = elem;
            }
            nodes.addChild(elem);
        }
    )+
    {
        nodes.setLocation(template, begin, elem);
        return nodes;
    }
}

/**
 * To be used between tags that in theory has nothing between, such between #switch and the first #case.
 */
ASTImplicitParent WhitespaceAndComments() :
{
    ASTImplicitParent nodes = new ASTImplicitParent();
    ASTElement elem, begin = null;
}
{
    (
        (
            elem = WhitespaceText()
            |
            elem = Comment()
        )
        {
            if (elem != null) { // not removed by stripText
	            if (begin == null) {
	                begin = elem;
	            }
	            nodes.addChild(elem);
            }
        }
    )+
    {
        if (begin == null // Was is removed by stripText?
                // Nodes here won't be ever executed anyway, but whitespace stripping should still remove the
                // lonely ASTStaticText from the AST, as that's purely source code formatting. If it's not lonely, then
                // there must be a comment, in which case the generic whitespace stripping algorithm will kick in.
                || stripWhitespace
                        && nodes.getChildCount() == 1 && nodes.getChild(0) instanceof ASTStaticText) {
            return null;
        }
        nodes.setLocation(template, begin, elem);
        return nodes;
    }
}

void HeaderElement() :
{
    Token key;
    ASTExpression exp = null;
    Token autoEscRequester = null;
}
{
    [<STATIC_TEXT_WS>]
    (
        <TRIVIAL_FTL_HEADER>
        |
        (
            <FTL_HEADER>
            (
                key = <ID>
                <ASSIGNMENT_EQUALS>
                exp = ASTExpression()
                {
                    String ks = key.image;
                    TemplateModel value = null;
                    try {
                        value = exp.eval(null);
                    } catch (Exception e) {
                        throw new ParseException(
                        		"Could not evaluate expression (on parse-time): " + exp.getCanonicalForm()
                        		+ " \nUnderlying cause: " +  e,
                                exp, e);
                    }
                    String vs = null;
                    if (value instanceof TemplateScalarModel) {
                        try {
                            vs = ((TemplateScalarModel) exp).getAsString();
                        } catch (TemplateModelException tme) {}
                    }
                    if (template != null) {
                        if (ks.equalsIgnoreCase("encoding")) {
                            if (vs == null) {
                                throw new ParseException("Expected a string constant for \"" + ks + "\".", exp);
                            }
                            Charset encoding;
                            try {
                                encoding = Charset.forName(vs);
                            } catch (UnsupportedCharsetException e) {
                                throw new ParseException("Unknown charset (check name, or ensure that the"
                                        + "charset is known by the runtime environment): " + vs,
                                        exp);
                            } catch (Exception e) {
                                throw new ParseException("Failed to resolve charset name: " + vs, exp, e
                                        .getCause());
                            }
                            if (template.getActualSourceEncoding() != null
                                    && !template.getActualSourceEncoding().equals(encoding)) {
                                throw new WrongTemplateCharsetException(encoding, template.getActualSourceEncoding());
                            }
                            // There will be no WrongTemplateCharsetException exception, release mark buffer:
                            if (streamToUnmarkWhenEncEstabd != null) {
                                streamToUnmarkWhenEncEstabd.mark(0);
                                streamToUnmarkWhenEncEstabd = null;
                            }
                        } else if (ks.equals("stripWhitespace")) {
                            this.stripWhitespace = getBoolean(exp, true);
                        } else if (ks.equals("stripText")) {
                            this.stripText = getBoolean(exp, true);
                        } else if (ks.equals("autoEsc")) {
                            if (getBoolean(exp, false)) {
                                autoEscRequester = key;
                                autoEscapingPolicy = AutoEscapingPolicy.ENABLE_IF_SUPPORTED;
                            } else {
                                autoEscapingPolicy = AutoEscapingPolicy.DISABLE;
                            }
                            recalculateAutoEscapingField();

                            template.setAutoEscapingPolicy(autoEscapingPolicy);
                        } else if (ks.equals("outputFormat")) {
                            if (vs == null) {
                                throw new ParseException("Expected a string constant for \"" + ks + "\".", exp);
                            }
                            try {
                                outputFormat = template.getConfiguration().getOutputFormat(vs);
					        } catch (IllegalArgumentException e) {
					            throw new ParseException("Invalid format name: " + e.getMessage(), exp, e.getCause());
					        } catch (UnregisteredOutputFormatException e) {
					            throw new ParseException(e.getMessage(), exp, e.getCause());
					        }
                            recalculateAutoEscapingField();

                            template.setOutputFormat(outputFormat);
                        } else if (ks.equals("nsPrefixes")) {
                            if (!(value instanceof TemplateHashModelEx)) {
                                throw new ParseException("Expecting a hash of prefixes to namespace URI's.", exp);
                            }
                            TemplateHashModelEx prefixMap = (TemplateHashModelEx) value;
                            try {
                                TemplateCollectionModel keys = prefixMap.keys();
                                for (TemplateModelIterator it = keys.iterator(); it.hasNext();) {
                                    String prefix = ((TemplateScalarModel) it.next()).getAsString();
                                    TemplateModel valueModel = prefixMap.get(prefix);
                                    if (!(valueModel instanceof TemplateScalarModel)) {
                                        throw new ParseException("Non-string value in prefix to namespace hash.", exp);
                                    }
                                    String nsURI = ((TemplateScalarModel) valueModel).getAsString();
                                    try {
                                        template.addPrefixNSMapping(prefix, nsURI);
                                    } catch (IllegalArgumentException iae) {
                                        throw new ParseException(iae.getMessage(), exp);
                                    }
                                }
                            } catch (TemplateModelException tme) {
                            }
                        } else if (ks.equals("customSettings")) {
                            if (!(value instanceof TemplateHashModelEx)) {
                                throw new ParseException("Expecting a hash value for custom settings.", exp);
                            }
                            TemplateHashModelEx attributeMap = (TemplateHashModelEx) value;
                            try {
                                TemplateCollectionModel keys = attributeMap.keys();
                                for (TemplateModelIterator it = keys.iterator(); it.hasNext();) {
                                        String attName = ((TemplateScalarModel) it.next()).getAsString();
                                        Object attValue = DeepUnwrap.unwrap(attributeMap.get(attName));
                                        if (attValue != null && !(attValue instanceof Serializable)) {
                                            throw new ParseException(
                                                    "Value of custom setting " + _StringUtil.jQuote(attName)
                                                    + " should implement java.io.Serializable.",
                                                    exp);
                                        }
                                        template.setHeaderCustomSetting(attName, (Serializable) attValue);
                                }
                            } catch (TemplateModelException tme) {
                            }
                        } else {
                            StringBuilder sb = new StringBuilder();
                            sb.append("Unknown header parameter: ").append(ks);

                            if (ks.indexOf('_') != -1) {
                                sb.append(MessageUtil.FM3_SNAKE_CASE);
                            }

                            String correctName;
                            switch (ks.toLowerCase()) {
	                        case "charset":
	                        case "source_encoding":
	                        case "sourcerncoding":
	                            correctName = "encoding";
	                            break;
	                        case "attributes":
	                        case "customsettings":
                            case "custom_settings":
                            case "settings":
	                            correctName = "customSettings";
	                            break;
	                        case "strip_whitespace":
                            case "stripwhitespace":
                            case "remove_whitespace":
                            case "removewhitespace":
	                            correctName = "stripWhitespace";
	                            break;
	                        case "strip_text":
	                        case "striptext":
                            case "remove_text":
                            case "removetext":
	                            correctName = "stripText";
	                            break;
	                        case "xmlns":
	                        case "ns_prefixes":
	                        case "nsprefixes":
                                correctName = "nsPrefixes";
                                break;
	                        case "output_format":
                            case "outputformat":
                                correctName = "outputFormat";
                                break;
                            case "autoescape":
                            case "autoescaping":
                            case "autoesc":
                            case "auto_escape":
                            case "auto_escaping":
                            case "auto_esc":
                                correctName = "autoEsc";
                                break;
	                        default:
                                correctName = null;
	                        }

	                        if (correctName != null) {
	                            sb.append("\nThe correct name is: ").append(correctName);
	                        }

                            throw new ParseException(sb.toString(), template, key);
                        }
                    }
                }
            )*
        )
        {
            if (autoEscRequester != null) {
                checkCurrentOutputFormatCanEscape(autoEscRequester);
            }        
        }
        LooseDirectiveEnd()
    )
}

Map ParamList() :
{
    ASTExpVariable id;
    ASTExpression exp;
    Map result = new HashMap();
}
{
    (
        id = ASTExpVariable()
        <ASSIGNMENT_EQUALS>
        exp = ASTExpression() { result.put(id.toString(), exp); }
        [<COMMA>]
    )+
    {
        return result;
    }
}

/**
 * Parses the already un-escaped content of a string literal (input must not include the quotation marks).
 *
 * @return A {@link List} of {@link String}-s and {@link ASTInterpolation}-s. 
 */
List<Object> StaticTextAndInterpolations() :
{
    Token t;
    ASTInterpolation interpolation;
    StringBuilder staticTextCollector = null;
    ArrayList<Object> parts = new ArrayList<Object>();
}
{
    (
	    (
		    t = <STATIC_TEXT_WS>
		    |
		    t = <STATIC_TEXT_NON_WS>
		    |
		    t = <STATIC_TEXT_FALSE_ALARM>
	    )
	    {
	       String s = t.image;
	       if (s.length() != 0) {
	           if (staticTextCollector == null) {
	               staticTextCollector = new StringBuilder(t.image);
	           } else {
	               staticTextCollector.append(t.image);
	           }
	       }
	    }
	    |
	    (
            interpolation = ASTDollarInterpolation()
	    )
	    {
            if (staticTextCollector != null) {
                parts.add(staticTextCollector.toString());
                staticTextCollector.setLength(0);
            }
            parts.add(interpolation);
	    }
    )*
    {
        if (staticTextCollector != null && staticTextCollector.length() != 0) {
            parts.add(staticTextCollector.toString());
        }
        parts.trimToSize();
        return parts;
    }
}

/**
 * Root production to be used when parsing
 * an entire file.
 */
ASTElement Root() :
{
    TemplateElements children;
}
{
    [
        LOOKAHEAD([<STATIC_TEXT_WS>](<TRIVIAL_FTL_HEADER>|<FTL_HEADER>))
        HeaderElement()
    ]
    {
        // There will be no WrongEncodingException exception, release mark buffer:
        if (streamToUnmarkWhenEncEstabd != null) {
            streamToUnmarkWhenEncEstabd.mark(0);
	        streamToUnmarkWhenEncEstabd = null;
        }
    }
    
    children = MixedContentElements()
    <EOF>
    {
        ASTElement root = children.asSingleElement(); 
        root.setFieldsForRootElement();
        root = root.postParseCleanup(stripWhitespace);
        // The cleanup result is possibly an element from deeper:
        root.setFieldsForRootElement();
        return root;
    }
}
